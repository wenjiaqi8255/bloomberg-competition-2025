"""
Box Allocator for Investment Framework

This module provides allocation strategies based on the Investment Box
classification system. It supports different methods for distributing
capital across various boxes (e.g., Size, Style, Sector, Region).

Key responsibilities:
- Implement box-level capital allocation logic.
- Support "Equal Weight" and "Active Tilt" allocation methods.
- Select top-performing assets within each box.
- Translate box-level weights into final asset weights.
"""

import logging
from typing import Dict, Any, List
import pandas as pd
import numpy as np

# Assuming InvestmentBox will be available via this path.
# This might need adjustment based on the final project structure.
from ..data.stock_classifier import InvestmentBox

logger = logging.getLogger(__name__)

class BoxAllocator:
    """
    Allocates capital based on the Investment Box structure, translating
    model predictions into a target portfolio based on box-level rules.
    """

    def __init__(self, config: Dict[str, Any]):
        """
        Initializes the BoxAllocator with a specific allocation configuration.

        Args:
            config: A dictionary containing allocation rules, typically from
                    the 'allocation' section of a strategy configuration file.
        """
        if not isinstance(config, dict):
            raise TypeError("BoxAllocator config must be a dictionary.")

        self.method = config.get('method', 'equal')
        self.stocks_per_box = int(config.get('stocks_per_box', 3))
        
        self.tilt_config = config.get('tilt_config', {}) if self.method == 'tilt' else {}
        self.max_deviation = self.tilt_config.get('max_deviation', 0.06)
        
        logger.info(
            f"BoxAllocator initialized. Method: '{self.method}', "
            f"Stocks per box: {self.stocks_per_box}"
        )
        if self.method == 'tilt':
            logger.info(f"Tilt config: Max deviation per box = Â±{self.max_deviation:.1%}")

    def allocate(self, 
                 predictions: pd.DataFrame, 
                 boxes: Dict[str, InvestmentBox]) -> pd.DataFrame:
        """
        Allocate weights to assets based on predictions and the box structure.

        This is the main entry point which routes to the specific allocation
        method configured during initialization.

        Args:
            predictions: DataFrame with symbols as columns and prediction scores
                         as values. Assumes a single row of the latest predictions.
            boxes: A dictionary of InvestmentBox objects generated by the
                   StockClassifier.

        Returns:
            A DataFrame with final portfolio weights for each asset, indexed by
            the same date as the predictions.
        """
        if not boxes:
            logger.warning("No investment boxes provided. Returning empty weights.")
            return pd.DataFrame(columns=predictions.columns, index=predictions.index)

        # Use the latest predictions (first row) as a Series
        latest_preds = predictions.iloc[0]

        if self.method == 'equal':
            weights = self._allocate_equal_weight(latest_preds, boxes)
        elif self.method == 'tilt':
            weights = self._allocate_tilt(latest_preds, boxes)
        else:
            logger.error(f"Unsupported allocation method: '{self.method}'")
            raise ValueError(f"Unsupported allocation method: '{self.method}'")
        
        # Format the output to match the expected DataFrame structure (date index, symbol columns)
        weights_df = pd.DataFrame(0, index=predictions.index, columns=predictions.columns, dtype=float)
        if not weights.empty:
            # Align the weights series to the DataFrame's columns, filling missing stocks with 0
            aligned_weights = weights.reindex(weights_df.columns, fill_value=0.0)
            weights_df.iloc[0] = aligned_weights
            weights_df = weights_df.ffill() # Forward fill for multi-day signals
        
        return weights_df

    def _get_top_stocks_in_box(self, box: InvestmentBox, predictions: pd.Series) -> List[str]:
        """Utility to get top N stocks from a box based on prediction scores."""
        box_stocks = [s['symbol'] for s in box.stocks]
        
        # Filter predictions for stocks available in the box
        relevant_preds = predictions.reindex(box_stocks).dropna()
        
        # Sort by prediction score and select top N
        top_stocks = relevant_preds.nlargest(self.stocks_per_box).index.tolist()
        return top_stocks

    def _allocate_equal_weight(self, predictions: pd.Series, boxes: Dict[str, InvestmentBox]) -> pd.Series:
        """
        Allocates capital equally among all qualifying investment boxes.
        """
        final_weights = {}
        
        # Filter for boxes that have stocks
        active_boxes = {key: box for key, box in boxes.items() if box.stocks}
        if not active_boxes:
            logger.warning("No active boxes with stocks found for equal weight allocation.")
            return pd.Series(final_weights, dtype=float)

        box_weight = 1.0 / len(active_boxes)
        
        logger.debug(f"Equal allocation: {len(active_boxes)} active boxes, each getting {box_weight:.2%} weight.")

        for box_key, box in active_boxes.items():
            top_stocks = self._get_top_stocks_in_box(box, predictions)
            if not top_stocks:
                continue

            stock_weight = box_weight / len(top_stocks)
            for stock in top_stocks:
                final_weights[stock] = stock_weight
        
        # Normalize to ensure weights sum exactly to 1.0
        weight_series = pd.Series(final_weights)
        return weight_series / weight_series.sum()

    def _allocate_tilt(self, predictions: pd.Series, boxes: Dict[str, InvestmentBox]) -> pd.Series:
        """
        Allocates capital based on active tilts away from a neutral (equal)
        weighting, driven by the attractiveness of each box.
        """
        final_weights = {}
        active_boxes = {key: box for key, box in boxes.items() if box.stocks}
        if not active_boxes:
            logger.warning("No active boxes with stocks found for tilt allocation.")
            return pd.Series(final_weights, dtype=float)

        # 1. Calculate box scores and identify top stocks for each
        box_scores = {}
        top_stocks_map = {}
        for key, box in active_boxes.items():
            top_stocks = self._get_top_stocks_in_box(box, predictions)
            if top_stocks:
                # Box score is the average prediction of its top stocks
                box_scores[key] = predictions[top_stocks].mean()
                top_stocks_map[key] = top_stocks

        if not box_scores:
            logger.warning("Could not calculate scores for any box.")
            return pd.Series(final_weights, dtype=float)

        scores = pd.Series(box_scores)
        
        # 2. Calculate z-score for normalization
        mean_score = scores.mean()
        std_score = scores.std()
        if std_score == 0: # Avoid division by zero if all scores are identical
            z_scores = pd.Series(0.0, index=scores.index)
        else:
            z_scores = (scores - mean_score) / std_score

        # 3. Calculate tilts based on z-scores
        # A simple linear tilt function. Can be made more complex.
        # We use max_deviation as a sensitivity factor.
        tilts = (z_scores * self.max_deviation / 2.0).clip(-self.max_deviation, self.max_deviation)

        # 4. Calculate final box weights
        neutral_weight = 1.0 / len(active_boxes)
        box_weights = neutral_weight + tilts
        
        # 5. Normalize box weights to ensure they sum to 1.0
        normalized_box_weights = box_weights / box_weights.sum()
        
        # 6. Allocate capital within each box
        for key, box_weight in normalized_box_weights.items():
            stocks_to_allocate = top_stocks_map.get(key, [])
            if not stocks_to_allocate:
                continue
            
            stock_weight = box_weight / len(stocks_to_allocate)
            for stock in stocks_to_allocate:
                final_weights[stock] = stock_weight
        
        # Final normalization of stock weights
        weight_series = pd.Series(final_weights)
        return weight_series / weight_series.sum()
