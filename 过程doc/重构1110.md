# è·¯å¾„Cå®Œæ•´é‡æ„æ–¹æ¡ˆï¼šé…ç½®é©±åŠ¨çš„Alphaä¿¡å·ç”Ÿæˆä¸ç»„åˆæ¶æ„

## ğŸ“‹ é‡æ„æ€»è§ˆ

### æ ¸å¿ƒç›®æ ‡

å°†å½“å‰çš„"éšå¼ä¾èµ– + å›ºå®šç»„åˆ"æ¶æ„ï¼Œé‡æ„ä¸º"æ˜¾å¼å¥‘çº¦ + é…ç½®é©±åŠ¨"çš„ç”Ÿäº§çº§ç³»ç»Ÿã€‚

### æˆåŠŸæ ‡å‡†

```
âœ… æ·»åŠ æ–°strategyåªéœ€å†™é…ç½®ï¼Œæ— éœ€æ”¹orchestrator
âœ… ä¸åŒstrategiesçš„æ•°æ®éœ€æ±‚åœ¨ç±»å‹ç³»ç»Ÿä¸­æ˜¾å¼å£°æ˜
âœ… Signal quality metadataè‡ªåŠ¨è®¡ç®—å¹¶ä¼ é€’
âœ… MetaStrategyæ ¹æ®ICåŠ¨æ€è°ƒæ•´æƒé‡
âœ… æ‰€æœ‰é…ç½®åœ¨åŠ è½½æ—¶éªŒè¯ï¼Œfail-fast
âœ… å®éªŒä¸åŒç»„åˆåªéœ€æ”¹YAMLï¼Œæ— éœ€æ”¹ä»£ç 
```

---

## ğŸ—ï¸ æ¶æ„åˆ†å±‚æ”¹é€ 

### æ”¹é€ å‰åå¯¹æ¯”

```
ã€å½“å‰æ¶æ„ã€‘
Orchestrator â†’ Dict[str, Any] â†’ Strategy â†’ pd.Series
                                    â†“
                              (éšå¼ä¾èµ–)
                                    â†“
                              FeaturePipeline

ã€ç›®æ ‡æ¶æ„ã€‘
CompetitionContext (é…ç½®æ³¨å…¥)
        â†“
Orchestrator â†’ DataRequirementséªŒè¯ â†’ PipelineData (å¼ºç±»å‹)
        â†“                                    â†“
   Validation                          Strategy
        â†“                                    â†“
    Fail-fast                    (Signals, SignalMetadata)
                                            â†“
                                     MetaStrategy
                                            â†“
                                  IC-weightedç»„åˆ
```

---

## ğŸ“¦ æ”¹é€ è®¡åˆ’ï¼šæŒ‰å±‚çº§å±•å¼€

---

## **Layer 0: ç±»å‹ç³»ç»ŸåŸºç¡€ (Foundation Types)**

### ç›®æ ‡
å»ºç«‹å¼ºç±»å‹çš„æ•°æ®å¥‘çº¦ï¼Œæ¶ˆé™¤Dict[str, Any]çš„éšå¼ä¾èµ–ã€‚

### æ¶‰åŠæ–‡ä»¶
```
æ–°å¢:
- src/trading_system/types/pipeline_data.py
- src/trading_system/types/signal_metadata.py
- src/trading_system/types/data_requirements.py

ä¿®æ”¹:
- æ— ï¼ˆçº¯æ–°å¢ï¼‰
```

### æ”¹é€ å†…å®¹

#### **1. PipelineData å¼ºç±»å‹å®šä¹‰**

**Context**: 
å½“å‰orchestratorè¿”å›Dict[str, Any]ï¼Œstrategiesä¸çŸ¥é“ä¼šæ”¶åˆ°ä»€ä¹ˆï¼Œåªèƒ½runtimeæ—¶æ‰å‘ç°ç¼ºå¤±æ•°æ®ã€‚

**æ”¹é€ è¦ç‚¹**:
- å®šä¹‰PipelineDataçš„TypedDictæˆ–Pydanticæ¨¡å‹
- åŒºåˆ†required fieldså’Œoptional fields
- æ”¯æŒæœªæ¥æ‰©å±•ï¼ˆæ–°çš„data typesï¼‰

**ç»“æ„è®¾è®¡**:
```
PipelineData (Pydantic BaseModel)
â”œâ”€ price_data: Dict[str, pd.DataFrame]  # required
â”œâ”€ returns_data: Optional[Dict[str, pd.Series]]  # optional
â”œâ”€ factor_data: Optional[FactorData]  # optional, æœ‰ä¸“é—¨çš„å­ç±»å‹
â”œâ”€ feature_data: Optional[FeatureData]  # optional
â””â”€ metadata: Dict[str, Any]  # æ‰©å±•ç”¨

FactorData (Pydantic BaseModel)
â”œâ”€ factors: pd.DataFrame  # columns: MKT-RF, SMB, HML, etc
â”œâ”€ factor_names: List[str]
â”œâ”€ frequency: Literal['daily', 'weekly', 'monthly']
â””â”€ source: str  # e.g., "Kenneth French Library"

FeatureData (Pydantic BaseModel)
â”œâ”€ features: pd.DataFrame
â”œâ”€ feature_names: List[str]
â”œâ”€ feature_groups: Dict[str, List[str]]  # 'technical', 'fundamental'
â””â”€ calculation_params: Dict[str, Any]
```

**è®¾è®¡ç†ç”±**:
- ä½¿ç”¨Pydanticè€ŒéTypedDict: æ”¯æŒvalidationå’Œnested structures
- åŒºåˆ†FactorDataå’ŒFeatureData: FF5å’ŒMLéœ€è¦ä¸åŒçš„æ•°æ®ç»“æ„
- metadataå­—æ®µ: ä¸ºæœªæ¥æ‰©å±•ç•™åé—¨ï¼Œä¸ç ´åå‘åå…¼å®¹æ€§

**æ•ˆæœ**:
- IDEè‡ªåŠ¨è¡¥å…¨: å†™`pipeline_data.`æ—¶èƒ½çœ‹åˆ°æ‰€æœ‰å¯ç”¨å­—æ®µ
- ç±»å‹æ£€æŸ¥: mypyèƒ½åœ¨ç¼–è¯‘æ—¶å‘ç°ç±»å‹é”™è¯¯
- Runtime validation: ä¼ å…¥é”™è¯¯ç±»å‹ä¼šç«‹å³æŠ¥é”™

---

#### **2. SignalMetadata å®šä¹‰**

**Context**: 
å½“å‰strategiesåªè¿”å›signals (pd.Series)ï¼ŒMetaStrategyä¸çŸ¥é“å“ªä¸ªsignalè´¨é‡æ›´å¥½ï¼Œåªèƒ½ç”¨å›ºå®šæƒé‡ç»„åˆã€‚

**æ”¹é€ è¦ç‚¹**:
- å®šä¹‰signalçš„å…ƒæ•°æ®ç»“æ„
- åŒ…å«è´¨é‡æŒ‡æ ‡ï¼ˆIC, decay, turnoverï¼‰
- åŒ…å«æ¥æºä¿¡æ¯ï¼ˆä¾¿äºè¿½æº¯ï¼‰

**ç»“æ„è®¾è®¡**:
```
SignalMetadata (Pydantic BaseModel)
â”œâ”€ strategy_name: str
â”œâ”€ signal_type: SignalType (enum)
â”œâ”€ quality_metrics: SignalQualityMetrics
â”œâ”€ alpha_decay: AlphaDecayParams
â””â”€ generation_info: GenerationInfo

SignalQualityMetrics (Pydantic BaseModel)
â”œâ”€ expected_ic: Optional[float]  # é¢„æœŸIC
â”œâ”€ realized_ic: Optional[float]  # å®é™…ICï¼ˆå›æµ‹æ—¶è®¡ç®—ï¼‰
â”œâ”€ confidence: float  # 0-1, ä¿¡å·ç½®ä¿¡åº¦
â”œâ”€ signal_coverage: float  # æœ‰ä¿¡å·çš„è‚¡ç¥¨å æ¯”
â””â”€ signal_intensity: float  # å¹³å‡ä¿¡å·å¼ºåº¦

AlphaDecayParams (Pydantic BaseModel)
â”œâ”€ halflife_days: Optional[int]  # alphaåŠè¡°æœŸ
â”œâ”€ decay_type: Literal['exponential', 'linear', 'step']
â”œâ”€ estimated_from_data: bool  # æ˜¯å¦ä»æ•°æ®ä¼°è®¡
â””â”€ last_updated: datetime

GenerationInfo (Pydantic BaseModel)
â”œâ”€ timestamp: datetime
â”œâ”€ data_range: Tuple[datetime, datetime]
â”œâ”€ universe_size: int
â””â”€ feature_version: str  # è¿½æº¯feature pipelineç‰ˆæœ¬
```

**è®¾è®¡ç†ç”±**:
- åˆ†å±‚ç»“æ„: ä¸åŒæ–¹é¢çš„metadataåˆ†å¼€ï¼Œé¿å…flat dict
- Optionalå­—æ®µ: æœ‰äº›metadataå¯èƒ½æ— æ³•è®¡ç®—ï¼ˆå¦‚é¢„æµ‹æ—¶ä¸çŸ¥é“realized_icï¼‰
- è¿½æº¯ä¿¡æ¯: generation_infoä¾¿äºdebugå’Œaudit

**æ•ˆæœ**:
- MetaStrategyèƒ½æ ¹æ®realized_icåŠ¨æ€è°ƒæƒ
- Backtestèƒ½åˆ†æä¸åŒstrategiesçš„IC decayç‰¹æ€§
- ä¾¿äºç›‘æ§signal quality degradation

---

#### **3. DataRequirements Protocol**

**Context**: 
å½“å‰strategiesçš„æ•°æ®éœ€æ±‚æ˜¯éšå¼çš„ï¼Œorchestratorä¸çŸ¥é“åº”è¯¥å‡†å¤‡ä»€ä¹ˆæ•°æ®ï¼Œåªèƒ½è¿è¡Œæ—¶æ‰å‘ç°ç¼ºå¤±ã€‚

**æ”¹é€ è¦ç‚¹**:
- å®šä¹‰Protocolå£°æ˜æ•°æ®éœ€æ±‚
- æ¯ä¸ªstrategyæ˜¾å¼å£°æ˜è‡ªå·±éœ€è¦ä»€ä¹ˆ
- Orchestratoræ ¹æ®requirementså‡†å¤‡æ•°æ®

**ç»“æ„è®¾è®¡**:
```
DataRequirements (Pydantic BaseModel)
â”œâ”€ requires_price_data: bool = True  # å‡ ä¹æ‰€æœ‰ç­–ç•¥éƒ½éœ€è¦
â”œâ”€ requires_returns_data: bool = False
â”œâ”€ requires_factor_data: Optional[FactorDataRequirement]
â”œâ”€ requires_feature_data: Optional[FeatureDataRequirement]
â””â”€ custom_requirements: Dict[str, Any]  # æ‰©å±•ç”¨

FactorDataRequirement (Pydantic BaseModel)
â”œâ”€ factor_model: Literal['FF3', 'FF5', 'Carhart4']
â”œâ”€ required_factors: List[str]  # ['MKT-RF', 'SMB', ...]
â”œâ”€ min_history_days: int  # æœ€å°‘éœ€è¦å¤šå°‘å¤©å†å²
â””â”€ frequency: Literal['daily', 'weekly', 'monthly']

FeatureDataRequirement (Pydantic BaseModel)
â”œâ”€ required_feature_groups: List[str]  # ['technical', 'momentum']
â”œâ”€ required_features: Optional[List[str]]  # å…·ä½“featureåç§°
â”œâ”€ min_history_days: int
â””â”€ calculation_params: Dict[str, Any]
```

**è®¾è®¡ç†ç”±**:
- Protocolè€ŒéABC: æ›´çµæ´»ï¼Œæ”¯æŒduck typing
- åµŒå¥—Requirements: factorå’Œfeatureæœ‰å„è‡ªçš„sub-requirements
- æ˜¾å¼min_history: é¿å…"æ•°æ®ä¸å¤Ÿ"çš„runtimeé”™è¯¯

**æ•ˆæœ**:
- Orchestratoråœ¨å‡†å¤‡æ•°æ®å‰çŸ¥é“æ‰€æœ‰requirements
- ç¼ºå¤±dependenciesæ—¶åœ¨åˆå§‹åŒ–é˜¶æ®µå°±fail
- æ–°å¢strategyæ—¶IDEèƒ½æç¤ºéœ€è¦å®ç°get_data_requirements()

---

### è°ƒç”¨å¤„æ”¹é€ 

#### **Orchestratorå±‚**
```
ã€å½“å‰ã€‘
def _prepare_pipeline_data(...) -> Dict[str, Any]:
    pipeline_data = {'price_data': ...}
    if self.factor_data_provider:
        pipeline_data['factor_data'] = ...
    return pipeline_data

ã€æ”¹é€ åã€‘
def _prepare_pipeline_data(
    self, 
    requirements: DataRequirements
) -> PipelineData:
    # 1. éªŒè¯æ˜¯å¦èƒ½æ»¡è¶³requirements
    self._validate_requirements(requirements)
    
    # 2. å‡†å¤‡price_dataï¼ˆæ€»æ˜¯éœ€è¦ï¼‰
    price_data = self._get_price_data(...)
    
    # 3. æ¡ä»¶å‡†å¤‡factor_data
    factor_data = None
    if requirements.requires_factor_data:
        if not self.factor_data_provider:
            raise MissingDependencyError(
                "Strategy requires factor_data but no provider configured"
            )
        factor_data = self._prepare_factor_data(
            requirements.requires_factor_data
        )
    
    # 4. ç»„è£…PipelineDataï¼ˆPydanticè‡ªåŠ¨éªŒè¯ï¼‰
    return PipelineData(
        price_data=price_data,
        factor_data=factor_data,
        metadata={'preparation_time': datetime.now()}
    )
```

**å…³é”®å˜åŒ–**:
1. æ¥æ”¶DataRequirementså‚æ•°ï¼ˆæ˜¾å¼å£°æ˜éœ€æ±‚ï¼‰
2. _validate_requirements() æ—©æœŸfail
3. è¿”å›PipelineDataè€ŒéDictï¼ˆç±»å‹å®‰å…¨ï¼‰
4. MissingDependencyErrorè€Œéwarningï¼ˆfail-fastï¼‰

#### **Strategyå±‚**
```
ã€å½“å‰ã€‘
class FamaFrench5Strategy(BaseStrategy):
    def _compute_features(self, pipeline_data: Dict[str, Any]):
        factor_data = pipeline_data.get('factor_data')
        if factor_data is None:
            logger.error("Missing factor_data!")
            return pd.DataFrame()
        ...

ã€æ”¹é€ åã€‘
class FamaFrench5Strategy(BaseStrategy):
    def get_data_requirements(self) -> DataRequirements:
        return DataRequirements(
            requires_factor_data=FactorDataRequirement(
                factor_model='FF5',
                required_factors=['MKT-RF', 'SMB', 'HML', 'RMW', 'CMA'],
                min_history_days=252
            )
        )
    
    def _compute_features(self, pipeline_data: PipelineData):
        # ä¸éœ€è¦æ£€æŸ¥Noneï¼Œorchestratorä¿è¯æä¾›
        factor_data = pipeline_data.factor_data.factors
        # IDEçŸ¥é“factor_dataçš„ç±»å‹ï¼Œèƒ½è‡ªåŠ¨è¡¥å…¨
        ...
```

**å…³é”®å˜åŒ–**:
1. æ–°å¢get_data_requirements()æ–¹æ³•ï¼ˆæ˜¾å¼å£°æ˜ï¼‰
2. ä¸å†éœ€è¦æ£€æŸ¥Noneï¼ˆorchestratorä¿è¯ï¼‰
3. ç±»å‹æ ‡æ³¨æ”¹ä¸ºPipelineDataï¼ˆIDEæ”¯æŒï¼‰
4. é”™è¯¯åœ¨orchestratorå±‚å¤„ç†ï¼ˆä¸å†silent failureï¼‰

---

### è¿ç§»ç­–ç•¥

**é˜¶æ®µ1: å®šä¹‰æ–°ç±»å‹ï¼ˆå…¼å®¹é˜¶æ®µï¼‰**
- å®šä¹‰æ‰€æœ‰æ–°ç±»å‹
- ä¸ä¿®æ”¹ç°æœ‰ä»£ç 
- å¯ä»¥å¹¶è¡Œå¼€å‘

**é˜¶æ®µ2: æ·»åŠ æ–°æ¥å£ï¼ˆå…±å­˜é˜¶æ®µï¼‰**
- BaseStrategyæ·»åŠ get_data_requirements()ï¼ˆoptionalï¼‰
- Orchestratoræ”¯æŒä¸¤ç§æ¨¡å¼ï¼ˆæ£€æŸ¥æ˜¯å¦æœ‰æ–°æ–¹æ³•ï¼‰
- é€ä¸ªstrategyè¿ç§»

**é˜¶æ®µ3: å¼ºåˆ¶æ–°æ¥å£ï¼ˆåˆ‡æ¢é˜¶æ®µï¼‰**
- get_data_requirements()å˜ä¸ºrequired
- åˆ é™¤æ—§çš„Dict[str, Any]ä»£ç è·¯å¾„
- è¿è¡Œå®Œæ•´æµ‹è¯•

**Breaking Changesç®¡ç†**:
- ç¬¬1é˜¶æ®µ: æ— breaking changes
- ç¬¬2é˜¶æ®µ: æ— breaking changesï¼ˆå‘åå…¼å®¹ï¼‰
- ç¬¬3é˜¶æ®µ: æœ‰breaking changesï¼ˆä½†å·²å……åˆ†æµ‹è¯•ï¼‰

---

## **Layer 1: BaseStrategyæ¥å£é‡æ„**

### ç›®æ ‡
ä¿®æ”¹BaseStrategyçš„æ ¸å¿ƒæ¥å£ï¼Œä½¿å…¶è¿”å›signals + metadataï¼Œæ”¯æŒé…ç½®é©±åŠ¨çš„ç‰¹å¾å·¥ç¨‹ã€‚

### æ¶‰åŠæ–‡ä»¶
```
ä¿®æ”¹:
- src/trading_system/strategies/base_strategy.py
- src/trading_system/strategies/ml_strategy.py
- src/trading_system/strategies/fama_french_5.py
- src/trading_system/strategies/fama_french_3.py

æ–°å¢:
- src/trading_system/strategies/signal_generator.py (æŠ½è±¡signalç”Ÿæˆé€»è¾‘)
```

### æ”¹é€ å†…å®¹

#### **1. BaseStrategyæ¥å£å‡çº§**

**Context**:
å½“å‰generate_signals()åªè¿”å›pd.Seriesï¼Œä¸”ç‰¹å¾å·¥ç¨‹é€»è¾‘ä¸ç­–ç•¥è€¦åˆï¼Œéš¾ä»¥å¤ç”¨ã€‚

**æ”¹é€ è¦ç‚¹**:
- generate_signals()è¿”å›(signals, metadata)
- å°†ç‰¹å¾å·¥ç¨‹æŠ½è±¡ä¸ºå¯é…ç½®çš„pipeline
- æ·»åŠ signal qualityè®¡ç®—é€»è¾‘

**æ¥å£å˜åŒ–**:
```
ã€å½“å‰æ¥å£ã€‘
class BaseStrategy(ABC):
    def generate_signals(
        self, 
        pipeline_data: Dict[str, Any], 
        **kwargs
    ) -> pd.Series:
        # 1. è®¡ç®—features
        features = self._compute_features(pipeline_data)
        # 2. é¢„æµ‹
        predictions = self._get_predictions({'features': features})
        # 3. å½’ä¸€åŒ–
        signals = self._normalize_signals(predictions)
        return signals

ã€æ–°æ¥å£ã€‘
class BaseStrategy(ABC):
    # æ–°å¢: å£°æ˜æ•°æ®éœ€æ±‚
    @abstractmethod
    def get_data_requirements(self) -> DataRequirements:
        pass
    
    # æ–°å¢: å£°æ˜signalç‰¹æ€§
    @abstractmethod
    def get_signal_characteristics(self) -> SignalCharacteristics:
        """è¿”å›è¯¥ç­–ç•¥ç”Ÿæˆçš„signalçš„é¢„æœŸç‰¹æ€§"""
        pass
    
    # ä¿®æ”¹: è¿”å›tuple
    def generate_signals(
        self,
        pipeline_data: PipelineData,  # ç±»å‹æ”¹å˜
        **kwargs
    ) -> Tuple[pd.Series, SignalMetadata]:
        # 1. è®¡ç®—featuresï¼ˆå¯èƒ½cachedï¼‰
        features = self._compute_features(pipeline_data)
        
        # 2. é¢„æµ‹
        predictions = self._get_predictions(features, pipeline_data)
        
        # 3. å½’ä¸€åŒ–
        signals = self._normalize_signals(predictions)
        
        # 4. è®¡ç®—metadataï¼ˆæ–°å¢ï¼‰
        metadata = self._compute_signal_metadata(
            signals, 
            features,
            pipeline_data
        )
        
        return signals, metadata
    
    # æ–°å¢: è®¡ç®—signalè´¨é‡
    def _compute_signal_metadata(
        self,
        signals: pd.Series,
        features: pd.DataFrame,
        pipeline_data: PipelineData
    ) -> SignalMetadata:
        """
        è®¡ç®—signalçš„è´¨é‡æŒ‡æ ‡å’Œå…ƒæ•°æ®
        å­ç±»å¯ä»¥overrideæä¾›æ›´ç²¾ç¡®çš„ä¼°è®¡
        """
        characteristics = self.get_signal_characteristics()
        
        quality_metrics = self._calculate_quality_metrics(signals)
        alpha_decay = self._estimate_alpha_decay(signals, pipeline_data)
        
        return SignalMetadata(
            strategy_name=self.name,
            signal_type=characteristics.signal_type,
            quality_metrics=quality_metrics,
            alpha_decay=alpha_decay,
            generation_info=GenerationInfo(
                timestamp=datetime.now(),
                data_range=self._get_data_range(pipeline_data),
                universe_size=len(signals),
                feature_version=self._get_feature_version()
            )
        )
```

**SignalCharacteristics**:
```
SignalCharacteristics (Pydantic BaseModel)
â”œâ”€ signal_type: SignalType  # CROSS_SECTIONAL, TIME_SERIES, FACTOR_TIMING
â”œâ”€ expected_ic_range: Tuple[float, float]  # (0.02, 0.05)
â”œâ”€ typical_turnover: float  # æœˆåº¦æ¢æ‰‹ç‡
â”œâ”€ rebalance_frequency: Literal['daily', 'weekly', 'monthly']
â””â”€ signal_interpretation: str  # æ–‡æ¡£è¯´æ˜
```

**è®¾è®¡ç†ç”±**:
- get_data_requirements(): æ˜¾å¼å£°æ˜ä¾èµ–
- get_signal_characteristics(): å­ç±»æä¾›ç­–ç•¥çš„expected behavior
- _compute_signal_metadata(): åŸºç±»æä¾›é»˜è®¤å®ç°ï¼Œå­ç±»å¯override
- Tupleè¿”å›å€¼: å¼ºåˆ¶metadataä¼ é€’

---

#### **2. ç‰¹å¾å·¥ç¨‹è§£è€¦**

**Context**:
å½“å‰_compute_features()åœ¨BaseStrategyä¸­ï¼Œæ¯ä¸ªå­ç±»éƒ½è¦å®ç°ï¼Œä½†logicå¾ˆç›¸ä¼¼ï¼ˆéƒ½æ˜¯è°ƒç”¨FeaturePipelineï¼‰ã€‚

**æ”¹é€ è¦ç‚¹**:
- å°†ç‰¹å¾å·¥ç¨‹æŠ½è±¡ä¸ºç‹¬ç«‹ç»„ä»¶
- é€šè¿‡é…ç½®æŒ‡å®šéœ€è¦å“ªäº›features
- æ”¯æŒfeature cachingå’Œversioning

**ç»“æ„å˜åŒ–**:
```
ã€å½“å‰ã€‘
class BaseStrategy:
    def _compute_features(self, pipeline_data):
        feature_pipeline = self._get_feature_pipeline()
        return feature_pipeline.transform(pipeline_data)
    
    @abstractmethod
    def _get_feature_pipeline(self):
        # æ¯ä¸ªå­ç±»è‡ªå·±å®ç°
        pass

ã€æ”¹é€ åã€‘
class BaseStrategy:
    def __init__(self, config: StrategyConfig):
        self.config = config
        # æ ¹æ®configåˆ›å»ºfeature pipeline
        self.feature_pipeline = FeaturePipelineFactory.create(
            config.feature_config
        )
    
    def _compute_features(self, pipeline_data: PipelineData):
        # ç»Ÿä¸€é€»è¾‘ï¼Œä¸éœ€è¦å­ç±»override
        return self.feature_pipeline.transform(pipeline_data)
```

**FeatureConfig**:
```
FeatureConfig (Pydantic BaseModel)
â”œâ”€ feature_groups: List[str]  # ['technical', 'momentum', 'volatility']
â”œâ”€ specific_features: Optional[List[str]]  # ç²¾ç¡®æŒ‡å®šfeature
â”œâ”€ calculation_params: Dict[str, Any]  # RSI_period=14, etc
â”œâ”€ cache_features: bool = True
â””â”€ feature_engineering_strategy: Literal['default', 'custom']
```

**è®¾è®¡ç†ç”±**:
- é…ç½®é©±åŠ¨: æ”¹å˜featuresåªéœ€æ”¹config
- Factoryåˆ›å»º: ç»Ÿä¸€åˆ›å»ºé€»è¾‘
- ç¼“å­˜æ”¯æŒ: é¿å…é‡å¤è®¡ç®—

---

#### **3. Signal Qualityè‡ªåŠ¨è®¡ç®—**

**Context**:
å½“å‰æ²¡æœ‰signal qualityçš„è®¡ç®—ï¼ŒMetaStrategyæ— æ³•æ„ŸçŸ¥signalå¥½åã€‚

**æ”¹é€ è¦ç‚¹**:
- åŸºç±»æä¾›é»˜è®¤çš„qualityè®¡ç®—é€»è¾‘
- å­ç±»å¯ä»¥overrideæä¾›æ›´å‡†ç¡®çš„ä¼°è®¡
- æ”¯æŒä»å†å²æ•°æ®ä¼°è®¡IC decay

**å®ç°é€»è¾‘**:
```
ã€_calculate_quality_metricså®ç°ã€‘
æ ¸å¿ƒé€»è¾‘:
1. Signal Coverage: 
   - è®¡ç®—æœ‰non-zero signalçš„è‚¡ç¥¨å æ¯”
   - coverageå¤ªä½è¯´æ˜ç­–ç•¥selectiveï¼Œé£é™©é›†ä¸­

2. Signal Intensity:
   - è®¡ç®—signalsçš„å¹³å‡ç»å¯¹å€¼
   - intensityå¤ªä½è¯´æ˜ä¿¡å·å¼±ï¼Œå¯èƒ½æ— æ•ˆ

3. Signal Consistency:
   - è®¡ç®—signalsçš„æ—¶é—´ç¨³å®šæ€§ï¼ˆautocorrelationï¼‰
   - consistencyé«˜è¯´æ˜ä¸æ˜¯å™ªéŸ³

4. Expected IC:
   - å¦‚æœæœ‰å†å²å›æµ‹æ•°æ®ï¼Œä½¿ç”¨realized IC
   - å¦åˆ™ä½¿ç”¨å­ç±»æä¾›çš„prior estimate
   - æˆ–è€…ä½¿ç”¨literature values (FF5: 0.03-0.04)

è¿”å›: SignalQualityMetricså¯¹è±¡
```

```
ã€_estimate_alpha_decayå®ç°ã€‘
æ ¸å¿ƒé€»è¾‘:
1. å¦‚æœæœ‰å†å²signals + returns:
   - è®¡ç®—IC decay curve (IC_t1, IC_t2, ..., IC_t20)
   - æ‹Ÿåˆexponential decay: IC(t) = IC_0 * exp(-t/halflife)
   - è¿”å›ä¼°è®¡çš„halflife

2. å¦‚æœæ²¡æœ‰å†å²æ•°æ®:
   - ä½¿ç”¨å­ç±»æä¾›çš„prior estimate
   - æˆ–è€…ä½¿ç”¨literature values:
     * Cross-sectional signals: 5-10 days
     * Factor momentum: 20-60 days
     * Residual momentum: 10-20 days

è¿”å›: AlphaDecayParamså¯¹è±¡
```

**è®¾è®¡ç†ç”±**:
- è‡ªåŠ¨è®¡ç®—: ç­–ç•¥å¼€å‘è€…ä¸éœ€è¦æ‰‹åŠ¨è®¡ç®—quality
- Fallbackæœºåˆ¶: æ²¡æœ‰å†å²æ•°æ®æ—¶ä½¿ç”¨prior
- å¯override: å­ç±»å¯ä»¥æä¾›æ›´ç²¾ç¡®çš„ä¼°è®¡

---

### è°ƒç”¨å¤„æ”¹é€ 

#### **MLStrategyè¿ç§»**

```
ã€å½“å‰ã€‘
class MLStrategy(BaseStrategy):
    def _get_feature_pipeline(self):
        return FeatureEngineeringPipeline(
            feature_groups=['technical', 'momentum']
        )
    
    def _get_predictions(self, feature_dict):
        features = feature_dict['features']
        return self.model.predict(features)

ã€æ”¹é€ åã€‘
class MLStrategy(BaseStrategy):
    def get_data_requirements(self) -> DataRequirements:
        return DataRequirements(
            requires_price_data=True,
            requires_feature_data=FeatureDataRequirement(
                required_feature_groups=['technical', 'momentum'],
                min_history_days=252
            )
        )
    
    def get_signal_characteristics(self) -> SignalCharacteristics:
        return SignalCharacteristics(
            signal_type=SignalType.CROSS_SECTIONAL,
            expected_ic_range=(0.03, 0.06),
            typical_turnover=0.5,  # 50% monthly
            rebalance_frequency='weekly',
            signal_interpretation="ML-predicted next-period returns"
        )
    
    def _get_predictions(self, features, pipeline_data):
        # ä¸å†éœ€è¦ä»dictå–features
        return self.model.predict(features)
    
    # å¯é€‰: override metadataè®¡ç®—
    def _estimate_alpha_decay(self, signals, pipeline_data):
        # ML signalsé€šå¸¸decayå¿«
        return AlphaDecayParams(
            halflife_days=7,
            decay_type='exponential',
            estimated_from_data=False
        )
```

**å…³é”®å˜åŒ–**:
1. åˆ é™¤_get_feature_pipeline()ï¼ˆç”¨configæ›¿ä»£ï¼‰
2. å®ç°get_data_requirements()ï¼ˆæ˜¾å¼å£°æ˜ï¼‰
3. å®ç°get_signal_characteristics()ï¼ˆæä¾›priorï¼‰
4. å¯é€‰override _estimate_alpha_decay()ï¼ˆæä¾›domain knowledgeï¼‰

---

#### **FamaFrench5Strategyè¿ç§»**

```
ã€å½“å‰ã€‘
class FamaFrench5Strategy(BaseStrategy):
    def _compute_features(self, pipeline_data):
        factor_data = pipeline_data.get('factor_data')
        if factor_data is None:
            logger.error("Missing factor_data")
            return pd.DataFrame()
        # è®¡ç®—FF5 regression...

ã€æ”¹é€ åã€‘
class FamaFrench5Strategy(BaseStrategy):
    def get_data_requirements(self) -> DataRequirements:
        return DataRequirements(
            requires_price_data=True,
            requires_factor_data=FactorDataRequirement(
                factor_model='FF5',
                required_factors=['MKT-RF', 'SMB', 'HML', 'RMW', 'CMA'],
                min_history_days=252,
                frequency='daily'
            )
        )
    
    def get_signal_characteristics(self) -> SignalCharacteristics:
        return SignalCharacteristics(
            signal_type=SignalType.RESIDUAL_MOMENTUM,
            expected_ic_range=(0.02, 0.04),
            typical_turnover=0.3,
            rebalance_frequency='monthly',
            signal_interpretation="FF5 residual alpha momentum"
        )
    
    def _compute_features(self, pipeline_data: PipelineData):
        # ä¸éœ€è¦æ£€æŸ¥Noneï¼Œorchestratorä¿è¯æä¾›
        factor_data = pipeline_data.factor_data.factors
        price_data = pipeline_data.price_data
        
        # è®¡ç®—FF5 regression residuals
        residuals = self._calculate_ff5_residuals(
            price_data, 
            factor_data
        )
        
        # è¿”å›features (è¿™é‡Œæ˜¯residuals)
        return residuals
    
    def _estimate_alpha_decay(self, signals, pipeline_data):
        # Residual momentumæœ‰è¾ƒæ…¢çš„decay
        return AlphaDecayParams(
            halflife_days=15,
            decay_type='exponential',
            estimated_from_data=False
        )
```

**å…³é”®å˜åŒ–**:
1. æ˜¾å¼å£°æ˜éœ€è¦FF5 factors
2. æä¾›expected IC rangeï¼ˆåŸºäºliteratureï¼‰
3. ä¸å†silent failureï¼ˆorchestratorä¼šfail-fastï¼‰
4. æä¾›domain-specific decay estimate

---

### è¿ç§»ç­–ç•¥

**é˜¶æ®µ1: æ‰©å±•BaseStrategyï¼ˆå‘åå…¼å®¹ï¼‰**
```
Week 1 Day 1-2:
- æ·»åŠ æ–°æ–¹æ³•get_data_requirements()ï¼ˆé»˜è®¤è¿”å›minimal requirementsï¼‰
- æ·»åŠ æ–°æ–¹æ³•get_signal_characteristics()ï¼ˆé»˜è®¤è¿”å›generic valuesï¼‰
- generate_signals()åŒæ—¶æ”¯æŒè¿”å›signalsæˆ–(signals, metadata)
- æ£€æµ‹å­ç±»æ˜¯å¦å®ç°æ–°æ–¹æ³•ï¼ŒåŠ¨æ€é€‰æ‹©è¡Œä¸º

å…¼å®¹æœºåˆ¶:
if hasattr(strategy, 'get_data_requirements'):
    requirements = strategy.get_data_requirements()
else:
    # ä½¿ç”¨é»˜è®¤requirements
    requirements = DataRequirements(requires_price_data=True)
```

**é˜¶æ®µ2: é€ä¸ªè¿ç§»strategiesï¼ˆå…±å­˜é˜¶æ®µï¼‰**
```
Week 1 Day 3:
- è¿ç§»MLStrategy
- æµ‹è¯•å•ç­–ç•¥è¿è¡Œ

Week 1 Day 4:
- è¿ç§»FF5Strategy
- è¿ç§»FF3Strategy
- æµ‹è¯•factor strategies

Week 1 Day 5:
- æµ‹è¯•æ‰€æœ‰strategies
- ç¡®ä¿æ²¡æœ‰regression
```

**é˜¶æ®µ3: å¼ºåˆ¶æ–°æ¥å£ï¼ˆåˆ‡æ¢é˜¶æ®µï¼‰**
```
Week 2å¼€å§‹:
- åˆ é™¤å…¼å®¹ä»£ç 
- å¼ºåˆ¶æ‰€æœ‰strategieså®ç°æ–°æ–¹æ³•
- generate_signals()åªè¿”å›tuple
```

---

## **Layer 2: MetaStrategyæ™ºèƒ½ç»„åˆ**

### ç›®æ ‡
ä»å›ºå®šæƒé‡ç»„åˆå‡çº§ä¸ºIC-aware adaptive weightingï¼Œå®ç°æ–¹æ¡ˆä¸­çš„"åŠ¨æ€è°ƒæƒ"ç›®æ ‡ã€‚

### æ¶‰åŠæ–‡ä»¶
```
ä¿®æ”¹:
- src/trading_system/strategies/meta_strategy.py

æ–°å¢:
- src/trading_system/strategies/combiners/base_combiner.py
- src/trading_system/strategies/combiners/fixed_weight_combiner.py
- src/trading_system/strategies/combiners/ic_weighted_combiner.py
- src/trading_system/strategies/combiners/adaptive_combiner.py
```

### æ”¹é€ å†…å®¹

#### **1. Signal CombineræŠ½è±¡**

**Context**:
å½“å‰MetaStrategyçš„ç»„åˆé€»è¾‘hardcodedåœ¨_combine_signals()æ–¹æ³•ä¸­ï¼Œæ— æ³•é€šè¿‡é…ç½®åˆ‡æ¢ä¸åŒç»„åˆç­–ç•¥ã€‚

**æ”¹é€ è¦ç‚¹**:
- æŠ½è±¡signal combinationä¸ºç‹¬ç«‹ç»„ä»¶
- æ”¯æŒå¤šç§ç»„åˆç®—æ³•
- é€šè¿‡é…ç½®é€‰æ‹©combiner

**Combineræ¶æ„**:
```
BaseCombiner (ABC)
â”œâ”€ combine(signals_dict, metadata_dict) -> (combined_signal, combined_metadata)
â”œâ”€ update_weights(performance_history) -> None
â””â”€ get_current_weights() -> Dict[str, float]

FixedWeightCombiner
â””â”€ ä½¿ç”¨é…ç½®æŒ‡å®šçš„å›ºå®šæƒé‡

ICWeightedCombiner
â””â”€ æ ¹æ®realized ICåŠ¨æ€è°ƒæƒ

AdaptiveCombiner
â””â”€ æ ¹æ®å¤šä¸ªmetrics (IC, Sharpe, turnover)ç»¼åˆè°ƒæƒ

EnsembleCombiner
â””â”€ æœºå™¨å­¦ä¹ based meta-model
```

**è®¾è®¡ç†ç”±**:
- ç­–ç•¥æ¨¡å¼: ä¸åŒcombinerå®ç°ä¸åŒç®—æ³•
- å¯é…ç½®: é€šè¿‡configé€‰æ‹©combiner
- å¯æ‰©å±•: æ–°å¢combinerä¸å½±å“ç°æœ‰ä»£ç 

---

#### **2. ICWeightedCombinerè¯¦ç»†è®¾è®¡**

**Context**:
æ–¹æ¡ˆè¦æ±‚æ ¹æ®æœ€è¿‘ICåŠ¨æ€è°ƒæ•´æƒé‡ï¼Œè¿™æ˜¯æ ¸å¿ƒåŠŸèƒ½ã€‚

**æ”¹é€ è¦ç‚¹**:
- è¿½è¸ªæ¯ä¸ªbase strategyçš„å†å²IC
- è®¡ç®—rolling IC
- æ ¹æ®ICè°ƒæ•´æƒé‡ï¼Œæ»¡è¶³çº¦æŸ

**æ ¸å¿ƒé€»è¾‘**:
```
ICWeightedCombinerçš„èŒè´£:

è¾“å…¥:
- signals_dict: Dict[str, pd.Series]  # strategy_name -> signals
- metadata_dict: Dict[str, SignalMetadata]  # strategy_name -> metadata
- performance_history: pd.DataFrame  # å†å²ICæ•°æ®

ç®—æ³•:
1. ä»metadataæå–expected_icå’Œrealized_ic
   
2. è®¡ç®—æ¯ä¸ªstrategyçš„IC score:
   score_i = w_expected * expected_ic + w_realized * rolling_ic(lookback)
   
   å…¶ä¸­:
   - w_expected: prior weight (å¦‚æœrealized_icä¸è¶³)
   - w_realized: é€æ¸å¢åŠ ï¼Œå½“æœ‰è¶³å¤Ÿå†å²æ•°æ®
   - rolling_ic: æœ€è¿‘NæœŸçš„å¹³å‡IC
   
3. å½’ä¸€åŒ–IC scoresä¸ºæƒé‡:
   raw_weight_i = max(0, score_i)  # è´ŸICè®¾ä¸º0
   normalized_weight_i = raw_weight_i / sum(raw_weights)
   
4. åº”ç”¨çº¦æŸ:
   - min_weight <= weight_i <= max_weight
   - sum(weights) = 1
   
   ä½¿ç”¨optimization:
   minimize: sum((weight_i - normalized_weight_i)^2)
   subject to: 
     - sum(weights) = 1
     - min_weight <= weight_i <= max_weight

5. ç»„åˆsignals:
   combined = sum(weight_i * signal_i)
   
6. ç”Ÿæˆcombined metadata:
   - expected_ic = sum(weight_i * ic_i)
   - turnover = sum(weight_i * turnover_i)
   - decay = weighted_avg(decay_i)

è¾“å‡º:
- combined_signal: pd.Series
- combined_metadata: SignalMetadata
```

**IC trackingæœºåˆ¶**:
```
performance_history DataFrameç»“æ„:
    date | strategy_name | realized_ic | turnover | signal_coverage
    -----|---------------|-------------|----------|----------------
    t-20 | MLStrategy    | 0.045       | 0.52     | 0.95
    t-20 | FF5Strategy   | 0.032       | 0.28     | 0.88
    t-19 | MLStrategy    | 0.038       | 0.51     | 0.94
    ...

å¦‚ä½•è®¡ç®—realized_ic:
1. åœ¨æ—¶é—´tï¼Œç­–ç•¥ç”Ÿæˆsignals_t
2. åœ¨æ—¶é—´t+1ï¼Œè§‚æµ‹åˆ°returns_{t+1}
3. è®¡ç®—IC_t = spearman_corr(signals_t, returns_{t+1})
4. å­˜å‚¨åˆ°performance_history

rolling_icè®¡ç®—:
rolling_ic_t = mean(IC_{t-lookback}, ..., IC_{t-1})
```

**é…ç½®æ¥å£**:
```
ICWeightedCombinerConfig (Pydantic BaseModel)
â”œâ”€ ic_lookback: int = 60  # ç”¨å¤šå°‘æœŸå†å²IC
â”œâ”€ min_history: int = 20  # è‡³å°‘éœ€è¦å¤šå°‘æœŸæ‰å¯ç”¨dynamic weighting
â”œâ”€ prior_weight: float = 0.3  # expected_icçš„æƒé‡
â”œâ”€ realized_weight: float = 0.7  # realized_icçš„æƒé‡
â”œâ”€ min_component_weight: float = 0.1  # æœ€å°æƒé‡
â”œâ”€ max_component_weight: float = 0.6  # æœ€å¤§æƒé‡
â”œâ”€ negative_ic_handling: Literal['zero', 'exclude', 'inverse']
â””â”€ rebalance_frequency: Literal['daily', 'weekly', 'monthly']
```

**è®¾è®¡ç†ç”±**:
- Rolling IC: æ•æ‰æœ€è¿‘è¡¨ç°ï¼Œé¿å…è¿‡åº¦ä¾èµ–å†å²
- Prior + Realized: åˆæœŸé priorï¼Œé€æ¸transitionåˆ°realized
- æƒé‡çº¦æŸ: é¿å…æç«¯é›†ä¸­æˆ–è¿‡åº¦åˆ†æ•£
- å¯é…ç½®: ä¸åŒcompetition contextéœ€è¦ä¸åŒå‚æ•°

---

#### **3. MetaStrategyé‡æ„**

**Context**:
å½“å‰MetaStrategyç›´æ¥åœ¨ç±»ä¸­hardcodeç»„åˆé€»è¾‘ï¼Œéœ€è¦è§£è€¦ä¸ºstrategy + combinerã€‚

**æ”¹é€ è¦ç‚¹**:
- MetaStrategyåªè´Ÿè´£orchestration
- å®é™…ç»„åˆé€»è¾‘å§”æ‰˜ç»™combiner
- æ”¯æŒé€šè¿‡é…ç½®åˆ‡æ¢combiner

**ç»“æ„å˜åŒ–**:
```
ã€å½“å‰ã€‘
class MetaStrategy(BaseStrategy):
    def __init__(self, base_strategies, meta_weights):
        self.base_strategies = base_strategies
        self.meta_weights = meta_weights
    
    def generate_signals(self, pipeline_data):
        # æ”¶é›†base signals
        base_signals = {}
        for strategy in self.base_strategies:
            signals = strategy.generate_signals(pipeline_data)
            base_signals[strategy.name] = signals
        
        # å›ºå®šæƒé‡ç»„åˆ
        combined = self._combine_signals(base_signals)
        return combined
    
    def _combine_signals(self, base_signals):
        combined = pd.Series(0, ...)
        for name, weight in self.meta_weights.items():
            combined += weight * base_signals[name]
        return combined

ã€æ”¹é€ åã€‘
class MetaStrategy(BaseStrategy):
    def __init__(
        self, 
        config: MetaStrategyConfig,
        base_strategies: List[BaseStrategy]
    ):
        self.config = config
        self.base_strategies = base_strategies
        
        # æ ¹æ®configåˆ›å»ºcombiner
        self.combiner = CombinerFactory.create(
            config.combination_config
        )
        
        # IC tracking
        self.performance_tracker = PerformanceTracker(
            config.tracking_config
        )
    
    def get_data_requirements(self) -> DataRequirements:
        # åˆå¹¶æ‰€æœ‰base strategiesçš„requirements
        return DataRequirements.merge([
            s.get_data_requirements() 
            for s in self.base_strategies
        ])
    
    def get_signal_characteristics(self) -> SignalCharacteristics:
        # ç»„åˆç­–ç•¥çš„ç‰¹æ€§æ˜¯weighted average
        return SignalCharacteristics.weighted_average([
            s.get_signal_characteristics()
            for s in self.base_strategies
        ], weights=self.combiner.get_current_weights())
    
    def generate_signals(
        self, 
        pipeline_data: PipelineData
    ) -> Tuple[pd.Series, SignalMetadata]:
        # 1. æ”¶é›†base signals + metadata
        base_signals = {}
        base_metadata = {}
        
        for strategy in self.base_strategies:
            signals, metadata = strategy.generate_signals(pipeline_data)
            base_signals[strategy.name] = signals
            base_metadata[strategy.name] = metadata
        
        # 2. å§”æ‰˜ç»™combinerç»„åˆ
        combined_signal, combined_metadata = self.combiner.combine(
            base_signals,
            base_metadata,
            self.performance_tracker.get_history()
        )
        
        # 3. è®°å½•æ€§èƒ½ï¼ˆç”¨äºä¸‹æ¬¡è°ƒæƒï¼‰
        self.performance_tracker.record_signals(
            base_signals,
            base_metadata
        )
        
        return combined_signal, combined_metadata
    
    def update_performance(
        self, 
        date: datetime, 
        realized_returns: pd.Series
    ):
        """
        åœ¨è§‚æµ‹åˆ°realized returnsåï¼Œè®¡ç®—ICå¹¶æ›´æ–°tracker
        è¿™ä¸ªæ–¹æ³•åœ¨backtest loopä¸­è°ƒç”¨
        """
        self.performance_tracker.update(date, realized_returns)
        
        # æ›´æ–°combinerçš„æƒé‡
        self.combiner.update_weights(
            self.performance_tracker.get_history()
        )
```

**MetaStrategyConfig**:
```
MetaStrategyConfig (Pydantic BaseModel)
â”œâ”€ name: str
â”œâ”€ base_strategy_configs: List[StrategyConfig]
â”œâ”€ combination_config: CombinationConfig
â””â”€ tracking_config: TrackingConfig

CombinationConfig (Pydantic BaseModel)
â”œâ”€ combiner_type: Literal['fixed', 'ic_weighted', 'adaptive']
â”œâ”€ combiner_params: Dict[str, Any]  # å¯¹åº”combinerçš„config
â””â”€ rebalance_weights_frequency: Literal['daily', 'weekly', 'monthly']

TrackingConfig (Pydantic BaseModel)
â”œâ”€ track_ic: bool = True
â”œâ”€ track_turnover: bool = True
â”œâ”€ track_coverage: bool = True
â”œâ”€ history_length: int = 252  # ä¿ç•™å¤šå°‘æœŸå†å²
â””â”€ storage_backend: Literal['memory', 'disk']
```

**è®¾è®¡ç†ç”±**:
- èŒè´£åˆ†ç¦»: MetaStrategyè´Ÿè´£orchestrationï¼Œcombinerè´Ÿè´£ç®—æ³•
- é…ç½®é©±åŠ¨: åˆ‡æ¢combineråªéœ€æ”¹config
- æ€§èƒ½è¿½è¸ª: ç‹¬ç«‹çš„trackerç»„ä»¶ï¼Œå¯ä»¥æŒä¹…åŒ–æˆ–åˆ†æ

---

### è°ƒç”¨å¤„æ”¹é€ 

#### **Orchestratorä¸­çš„MetaStrategyä½¿ç”¨**

```
ã€å½“å‰ã€‘
# åœ¨orchestratorä¸­
meta_strategy = MetaStrategy(
    base_strategies=[ml_strategy, ff5_strategy],
    meta_weights={'ml': 0.6, 'ff5': 0.4}
)
signals = meta_strategy.generate_signals(pipeline_data)

ã€æ”¹é€ åã€‘
# é€šè¿‡configåˆ›å»º
meta_config = MetaStrategyConfig(
    name="Ensemble_ML_FF5",
    base_strategy_configs=[
        {'type': 'ml', 'name': 'ML', ...},
        {'type': 'fama_french_5', 'name': 'FF5', ...}
    ],
    combination_config=CombinationConfig(
        combiner_type='ic_weighted',
        combiner_params={
            'ic_lookback': 60,
            'min_component_weight': 0.2,
            'max_component_weight': 0.7
        }
    )
)

meta_strategy = StrategyFactory.create_from_config(meta_config)

# ä½¿ç”¨æ—¶ä¸€æ ·
signals, metadata = meta_strategy.generate_signals(pipeline_data)

# åœ¨backtest loopä¸­ï¼Œè§‚æµ‹åˆ°returnsåæ›´æ–°
meta_strategy.update_performance(current_date, realized_returns)
```

**å…³é”®å˜åŒ–**:
1. é…ç½®åŒ–åˆ›å»ºï¼ˆä¸hardcode weightsï¼‰
2. è¿”å›tuple (signals, metadata)
3. éœ€è¦è°ƒç”¨update_performance()æ¥æ›´æ–°IC

---

#### **Backtest Loopçš„æ”¹é€ **

```
ã€å½“å‰backtest loopã€‘
for date in dates:
    pipeline_data = prepare_data(date)
    signals = strategy.generate_signals(pipeline_data)
    positions = portfolio_optimizer.optimize(signals)
    # ä¸‹ä¸€æœŸ...

ã€æ”¹é€ åbacktest loopã€‘
for date in dates:
    # 1. å‡†å¤‡æ•°æ®
    pipeline_data = prepare_data(date)
    
    # 2. ç”Ÿæˆsignals + metadata
    signals, metadata = strategy.generate_signals(pipeline_data)
    
    # 3. Portfolio construction (å¯ä»¥ä½¿ç”¨metadata)
    positions = portfolio_optimizer.optimize(
        signals, 
        metadata,  # optimizerå¯ä»¥ä½¿ç”¨decayç­‰ä¿¡æ¯
        competition_context
    )
    
    # 4. è®°å½•è¿™ä¸€æœŸçš„signalså’Œpositions
    backtest_record[date] = {
        'signals': signals,
        'metadata': metadata,
        'positions': positions
    }
    
    # 5. åˆ°ä¸‹ä¸€æœŸï¼Œè§‚æµ‹realized returns
    next_date = dates[dates.index(date) + 1]
    realized_returns = get_returns(date, next_date)
    
    # 6. æ›´æ–°ç­–ç•¥çš„performance tracker
    if isinstance(strategy, MetaStrategy):
        strategy.update_performance(date, realized_returns)
    
    # 7. ç»§ç»­ä¸‹ä¸€è½®
```

**å…³é”®å˜åŒ–**:
1. signalså˜æˆtupleè§£åŒ…
2. metadataä¼ é€’ç»™optimizerï¼ˆå¯é€‰ä½¿ç”¨ï¼‰
3. éœ€è¦è°ƒç”¨update_performance()ï¼ˆå¯¹MetaStrategyï¼‰
4. è®°å½•metadataç”¨äºäº‹ååˆ†æ

---

### è¿ç§»ç­–ç•¥

**é˜¶æ®µ1: å®ç°Combineræ¡†æ¶ï¼ˆç‹¬ç«‹å¼€å‘ï¼‰**
```
Week 2 Day 1:
- å®ç°BaseCombineræŠ½è±¡ç±»
- å®ç°FixedWeightCombinerï¼ˆç­‰ä»·äºå½“å‰è¡Œä¸ºï¼‰
- æµ‹è¯•FixedWeightCombinerä¸å½“å‰MetaStrategyç­‰ä»·

æ— breaking changes
```

**é˜¶æ®µ2: å®ç°ICWeightedCombinerï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰**
```
Week 2 Day 2:
- å®ç°PerformanceTracker
- å®ç°ICè®¡ç®—é€»è¾‘
- å®ç°ICWeightedCombiner

Week 2 Day 3:
- å•å…ƒæµ‹è¯•combineré€»è¾‘
- æ¨¡æ‹Ÿæ•°æ®æµ‹è¯•æƒé‡è°ƒæ•´
```

**é˜¶æ®µ3: é‡æ„MetaStrategyï¼ˆé›†æˆï¼‰**
```
Week 2 Day 4:
- é‡æ„MetaStrategyä½¿ç”¨combiner
- å…ˆé»˜è®¤ä½¿ç”¨FixedWeightCombinerï¼ˆå‘åå…¼å®¹ï¼‰
- æ·»åŠ update_performance()æ–¹æ³•

å…¼å®¹ç­–ç•¥:
- å¦‚æœconfigæ²¡æœ‰æŒ‡å®šcombinerï¼Œä½¿ç”¨FixedWeight + å½“å‰meta_weights
- å¦‚æœconfigæŒ‡å®šäº†combinerï¼Œä½¿ç”¨æ–°é€»è¾‘
```

**é˜¶æ®µ4: æ›´æ–°Backtestæ¡†æ¶ï¼ˆé›†æˆç‚¹ï¼‰**
```
Week 2 Day 5:
- ä¿®æ”¹backtest loopæ”¯æŒupdate_performance()
- æµ‹è¯•end-to-end flow
- å¯¹æ¯”fixed vs ic_weightedæ€§èƒ½
```

---

## **Layer 3: Configurationç³»ç»Ÿå®Œå–„**

### ç›®æ ‡
å»ºç«‹å®Œæ•´çš„Pydantic-basedé…ç½®ç³»ç»Ÿï¼Œæ”¯æŒschema validationã€å®éªŒçŸ©é˜µã€competition contextæ³¨å…¥ã€‚

### æ¶‰åŠæ–‡ä»¶
```
æ–°å¢:
- src/trading_system/config/schemas/strategy_config.py
- src/trading_system/config/schemas/competition_config.py
- src/trading_system/config/schemas/experiment_config.py
- src/trading_system/config/validators.py
- src/trading_system/config/presets.py

ä¿®æ”¹:
- src/trading_system/strategies/factory.py
- src/trading_system/config/config_loader.py
```

### æ”¹é€ å†…å®¹

#### **1. å®Œæ•´çš„Config Schemaå®šä¹‰**

**Context**:
å½“å‰configæ˜¯YAMLç›´æ¥loadæˆdictï¼Œæ²¡æœ‰type checkingå’Œvalidationã€‚

**æ”¹é€ è¦ç‚¹**:
- ç”¨Pydanticå®šä¹‰æ‰€æœ‰config schemas
- åŠ è½½æ—¶è‡ªåŠ¨validation
- æä¾›IDEè‡ªåŠ¨è¡¥å…¨

**Schemaå±‚çº§**:
```
RootConfig (Pydantic BaseModel)
â”œâ”€ competition: CompetitionConfig
â”œâ”€ strategies: Dict[str, StrategyConfig]
â”œâ”€ orchestration: OrchestrationConfig
â”œâ”€ backtesting: BacktestConfig
â””â”€ logging: LoggingConfig

CompetitionConfig (Pydantic BaseModel)
â”œâ”€ objective: Literal['total_return', 'sharpe', 'max_drawdown']
â”œâ”€ rebalance_frequency: Literal['daily', 'weekly', 'monthly']
â”œâ”€ universe: UniverseConfig
â”œâ”€ constraints: ConstraintsConfig
â””â”€ evaluation: EvaluationConfig

StrategyConfig (Pydantic BaseModel)
â”œâ”€ type: str  # 'ml', 'fama_french_5', 'meta'
â”œâ”€ name: str
â”œâ”€ model_id: Optional[str]
â”œâ”€ feature_config: Optional[FeatureConfig]
â”œâ”€ signal_config: Optional[SignalConfig]
â””â”€ type_specific_params: Dict[str, Any]  # æ¯ç§strategyç‰¹æœ‰çš„

# ä½¿ç”¨Discriminated Unionå¤„ç†ä¸åŒstrategy types
StrategyConfig = Annotated[
    Union[
        MLStrategyConfig,
        FF5StrategyConfig,
        FF3StrategyConfig,
        MetaStrategyConfig
    ],
    Field(discriminator='type')
]
```

**Discriminated Unionçš„å¥½å¤„**:
```
# å½“type='ml'æ—¶ï¼ŒPydanticè‡ªåŠ¨çŸ¥é“åº”è¯¥æ˜¯MLStrategyConfig
ml_config = StrategyConfig(
    type='ml',
    name='ML',
    model_id='xgb_v1',
    feature_config=FeatureConfig(...)
    # Pydanticä¼šæ£€æŸ¥æ˜¯å¦ç¬¦åˆMLStrategyConfigçš„schema
)

# IDEè‡ªåŠ¨è¡¥å…¨ä¼šæ ¹æ®typeæ˜¾ç¤ºä¸åŒå­—æ®µ
config = StrategyConfig(type='fama_french_5', ...)
# è¿™é‡ŒIDEçŸ¥é“éœ€è¦factor_configï¼Œä¸éœ€è¦model_id
```

---

#### **2. Validatorå®ç°**

**Context**:
é™¤äº†ç±»å‹æ£€æŸ¥ï¼Œè¿˜éœ€è¦ä¸šåŠ¡é€»è¾‘validationï¼ˆå¦‚FF5å¿…é¡»æœ‰factor_data_providerï¼‰ã€‚

**æ”¹é€ è¦ç‚¹**:
- ä½¿ç”¨Pydanticçš„validator decorator
- å®ç°cross-field validation
- å®ç°dependency checking

**Validatorç¤ºä¾‹**:
```
class FF5StrategyConfig(BaseModel):
    type: Literal['fama_french_5']
    name: str
    lookback_window: int
    formation_period: int
    
    # Field-level validation
    @validator('lookback_window')
    def validate_lookback(cls, v):
        if v < 60:
            raise ValueError(
                "FF5 regression needs at least 60 observations"
            )
        if v > 1000:
            raise ValueError(
                "Lookback too long, may cause overfitting"
            )
        return v
    
    # Cross-field validation
    @root_validator
    def validate_periods(cls, values):
        lookback = values.get('lookback_window')
        formation = values.get('formation_period')
        
        if formation > lookback:
            raise ValueError(
                f"Formation period ({formation}) cannot be longer "
                f"than lookback window ({lookback})"
            )
        
        return values

class MetaStrategyConfig(BaseModel):
    type: Literal['meta']
    base_strategy_configs: List[StrategyConfig]
    combination_config: CombinationConfig
    
    # Dependency validation
    @validator('base_strategy_configs')
    def validate_base_strategies(cls, v):
        if len(v) < 2:
            raise ValueError(
                "MetaStrategy needs at least 2 base strategies"
            )
        
        # æ£€æŸ¥base strategiesçš„data requirementsæ˜¯å¦å…¼å®¹
        requirements = [
            get_requirements_for_config(cfg) 
            for cfg in v
        ]
        
        if not are_requirements_compatible(requirements):
            raise ValueError(
                "Base strategies have incompatible data requirements"
            )
        
        return v
    
    @root_validator
    def validate_combiner_compatibility(cls, values):
        combiner_type = values.get('combination_config').combiner_type
        base_strategies = values.get('base_strategy_configs')
        
        # IC-weightedéœ€è¦æ‰€æœ‰base strategiesæ”¯æŒICè®¡ç®—
        if combiner_type == 'ic_weighted':
            for cfg in base_strategies:
                if not supports_ic_calculation(cfg):
                    raise ValueError(
                        f"Strategy {cfg.name} doesn't support IC calculation, "
                        f"cannot use ic_weighted combiner"
                    )
        
        return values
```

**è®¾è®¡ç†ç”±**:
- Fail-fast: é…ç½®åŠ è½½æ—¶å°±å‘ç°é”™è¯¯
- Clear messages: å‘Šè¯‰ç”¨æˆ·å“ªé‡Œé”™äº†ï¼Œæ€ä¹ˆæ”¹
- Business logic: ä¸åªæ˜¯ç±»å‹æ£€æŸ¥ï¼Œè¿˜æœ‰é‡‘èé€»è¾‘

---

#### **3. Presetç³»ç»Ÿ**

**Context**:
ç”¨æˆ·ä¸æƒ³æ¯æ¬¡éƒ½å†™å®Œæ•´é…ç½®ï¼Œéœ€è¦æä¾›å¸¸ç”¨çš„é¢„è®¾ã€‚

**æ”¹é€ è¦ç‚¹**:
- å®šä¹‰preset configs
- æ”¯æŒç»§æ‰¿å’Œoverride
- æä¾›ä¸åŒcompetition scenariosçš„preset

**Presetè®¾è®¡**:
```
# config/presets/strategies.yaml
strategy_presets:
  # ç®€å•é¢„è®¾
  ml_default:
    type: ml
    feature_config:
      feature_groups: [technical, momentum, volatility]
      calculation_params:
        RSI_period: 14
        MACD_fast: 12
        MACD_slow: 26
  
  ff5_conservative:
    type: fama_french_5
    lookback_window: 252
    formation_period: 126
    skip_recent_days: 21
  
  # ç»„åˆé¢„è®¾
  ensemble_ml_ff5:
    type: meta
    base_presets: [ml_default, ff5_conservative]
    combination_config:
      combiner_type: ic_weighted
      combiner_params:
        ic_lookback: 60
        min_component_weight: 0.2

# config/presets/competition.yaml
competition_presets:
  aggressive:
    rebalance_frequency: weekly
    expected_txn_cost_bps: 5
    constraints:
      max_position_weight: 0.1
      max_sector_weight: 0.3
  
  conservative:
    rebalance_frequency: monthly
    expected_txn_cost_bps: 2
    constraints:
      max_position_weight: 0.05
      max_sector_weight: 0.25
```

**ä½¿ç”¨æ–¹å¼**:
```
# config/my_experiment.yaml
competition:
  preset: aggressive  # ç»§æ‰¿preset
  overrides:  # è¦†ç›–éƒ¨åˆ†å‚æ•°
    rebalance_frequency: daily

strategies:
  ml_strategy:
    preset: ml_default
    overrides:
      feature_config:
        calculation_params:
          RSI_period: 21  # åªæ”¹è¿™ä¸€ä¸ªå‚æ•°
  
  ensemble:
    preset: ensemble_ml_ff5
    # ä¸æ”¹ä»»ä½•å‚æ•°
```

**è®¾è®¡ç†ç”±**:
- DRY: é¿å…é‡å¤é…ç½®
- æ˜“ç”¨æ€§: æ–°æ‰‹ç”¨presetï¼Œé«˜çº§ç”¨æˆ·override
- æœ€ä½³å®è·µ: presetç¼–ç proven configurations

---

#### **4. Experiment Matrixæ”¯æŒ**

**Context**:
ä½ éœ€è¦æ¯”è¾ƒä¸åŒé…ç½®çš„æ€§èƒ½ï¼Œéœ€è¦æ‰¹é‡è¿è¡Œå®éªŒã€‚

**æ”¹é€ è¦ç‚¹**:
- å®šä¹‰experiment config
- æ”¯æŒå‚æ•°grid search
- è‡ªåŠ¨ç”Ÿæˆå®éªŒé…ç½®

**Experiment Config**:
```
ExperimentConfig (Pydantic BaseModel)
â”œâ”€ name: str
â”œâ”€ base_config: RootConfig  # åŸºç¡€é…ç½®
â”œâ”€ variations: List[ConfigVariation]  # å˜åŒ–ç»´åº¦
â”œâ”€ metrics: List[str]  # è¦è®°å½•çš„metrics
â””â”€ output_dir: Path  # ç»“æœä¿å­˜ä½ç½®

ConfigVariation (Pydantic BaseModel)
â”œâ”€ name: str
â”œâ”€ config_path: str  # å¦‚ "competition.rebalance_frequency"
â”œâ”€ values: List[Any]  # è¦æµ‹è¯•çš„å€¼
â””â”€ description: str

# ä¾‹å¦‚
experiment = ExperimentConfig(
    name="Rebalance_Frequency_Sweep",
    base_config=load_config("base.yaml"),
    variations=[
        ConfigVariation(
            name="rebalance_freq",
            config_path="competition.rebalance_frequency",
            values=["daily", "weekly", "monthly"]
        ),
        ConfigVariation(
            name="ic_lookback",
            config_path="strategies.ensemble.combination_config.combiner_params.ic_lookback",
            values=[20, 40, 60, 80]
        )
    ],
    metrics=["total_return", "sharpe_ratio", "max_drawdown", "turnover"]
)

# è‡ªåŠ¨ç”Ÿæˆ 3 x 4 = 12ä¸ªé…ç½®
configs = experiment.generate_configs()
```

**ExperimentRunner**:
```
ExperimentRunnerçš„èŒè´£:

1. ç”Ÿæˆæ‰€æœ‰å®éªŒé…ç½®ç»„åˆ
2. éªŒè¯æ¯ä¸ªé…ç½®çš„åˆæ³•æ€§
3. å¹¶è¡Œè¿è¡Œbacktest (å¦‚æœå¯èƒ½)
4. æ”¶é›†æ‰€æœ‰metrics
5. ç”Ÿæˆå¯¹æ¯”æŠ¥å‘Š

è¿è¡Œæµç¨‹:
runner = ExperimentRunner(experiment_config)
results = runner.run_all()
# è¿”å›: DataFrame with columns [config_id, param1, param2, ..., metric1, metric2, ...]

runner.generate_report(results, output_path="results/experiment_1/")
# ç”Ÿæˆ:
# - results.csv: æ‰€æœ‰ç»“æœ
# - best_configs.yaml: top 5 configs
# - plots/: å„ç§å¯è§†åŒ–
# - analysis.md: è‡ªåŠ¨ç”Ÿæˆçš„åˆ†ææŠ¥å‘Š
```

**è®¾è®¡ç†ç”±**:
- è‡ªåŠ¨åŒ–: ä¸éœ€è¦æ‰‹åŠ¨å†™Nä¸ªconfigæ–‡ä»¶
- ç³»ç»ŸåŒ–: æ‰€æœ‰å®éªŒä½¿ç”¨ç»Ÿä¸€æ ¼å¼
- å¯è¿½æº¯: æ¯ä¸ªå®éªŒç»“æœå…³è”åˆ°ç²¾ç¡®çš„config

---

### è°ƒç”¨å¤„æ”¹é€ 

#### **ConfigLoaderæ”¹é€ **

```
ã€å½“å‰ã€‘
class ConfigLoader:
    def load(self, path: str) -> dict:
        with open(path) as f:
            return yaml.safe_load(f)

ã€æ”¹é€ åã€‘
class ConfigLoader:
    def load(self, path: str) -> RootConfig:
        # 1. Load YAML
        with open(path) as f:
            raw_config = yaml.safe_load(f)
        
        # 2. å¤„ç†presetç»§æ‰¿
        resolved_config = self._resolve_presets(raw_config)
        
        # 3. Pydantic validation
        try:
            config = RootConfig(**resolved_config)
        except ValidationError as e:
            # ç¾åŒ–é”™è¯¯ä¿¡æ¯
            raise ConfigValidationError(
                f"Invalid config at {path}:\n{self._format_errors(e)}"
            )
        
        # 4. é¢å¤–çš„cross-config validation
        self._validate_cross_config(config)
        
        return config
    
    def _resolve_presets(self, config: dict) -> dict:
        """
        å¤„ç†presetå’Œoverride
        ä¾‹å¦‚:
            preset: ml_default
            overrides:
              feature_config:
                calculation_params:
                  RSI_period: 21
        """
        if 'preset' in config:
            base = self.load_preset(config['preset'])
            overrides = config.get('overrides', {})
            return deep_merge(base, overrides)
        return config
    
    def _validate_cross_config(self, config: RootConfig):
        """
        è·¨config sectionçš„validation
        ä¾‹å¦‚: å¦‚æœstrategyéœ€è¦factor_dataï¼Œæ£€æŸ¥orchestrationæœ‰factor_provider
        """
        # æ”¶é›†æ‰€æœ‰strategiesçš„data requirements
        all_requirements = []
        for strategy_config in config.strategies.values():
            req = get_requirements_for_config(strategy_config)
            all_requirements.append(req)
        
        # æ£€æŸ¥orchestrationèƒ½å¦æ»¡è¶³
        orchestration = config.orchestration
        for req in all_requirements:
            if req.requires_factor_data:
                if not orchestration.has_factor_data_provider:
                    raise ConfigValidationError(
                        f"Strategy requires factor_data but "
                        f"orchestration.factor_data_provider not configured"
                    )
```

**å…³é”®å˜åŒ–**:
1. è¿”å›å¼ºç±»å‹RootConfigï¼ˆä¸æ˜¯dictï¼‰
2. preset resolutionï¼ˆDRYï¼‰
3. å¤šå±‚validationï¼ˆtype + business logic + cross-configï¼‰
4. æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯

---

#### **StrategyFactoryæ”¹é€ **

```
ã€å½“å‰ã€‘
class StrategyFactory:
    @staticmethod
    def create_from_config(config: dict) -> BaseStrategy:
        strategy_type = config['type']
        if strategy_type not in STRATEGY_REGISTRY:
            raise ValueError(f"Unknown strategy: {strategy_type}")
        
        strategy_class = STRATEGY_REGISTRY[strategy_type]
        return strategy_class(**config)

ã€æ”¹é€ åã€‘
class StrategyFactory:
    @staticmethod
    def create_from_config(config: StrategyConfig) -> BaseStrategy:
        # configå·²ç»æ˜¯validatedçš„Pydantic model
        
        # ä½¿ç”¨discriminated unionè‡ªåŠ¨dispatch
        if isinstance(config, MLStrategyConfig):
            return MLStrategy(config)
        elif isinstance(config, FF5StrategyConfig):
            return FamaFrench5Strategy(config)
        elif isinstance(config, MetaStrategyConfig):
            # Metaéœ€è¦å…ˆåˆ›å»ºbase strategies
            base_strategies = [
                StrategyFactory.create_from_config(base_cfg)
                for base_cfg in config.base_strategy_configs
            ]
            return MetaStrategy(config, base_strategies)
        else:
            raise ValueError(f"Unknown strategy type: {type(config)}")
    
    @staticmethod
    def create_with_validation(
        config: StrategyConfig,
        orchestrator_capabilities: OrchestratorCapabilities
    ) -> BaseStrategy:
        """
        åˆ›å»ºstrategyå‰éªŒè¯orchestratorèƒ½å¦æ»¡è¶³å…¶éœ€æ±‚
        """
        # å…ˆåˆ›å»ºstrategyï¼ˆè·å–å…¶requirementsï¼‰
        strategy = StrategyFactory.create_from_config(config)
        
        # éªŒè¯requirements
        requirements = strategy.get_data_requirements()
        if not orchestrator_capabilities.can_satisfy(requirements):
            raise ConfigValidationError(
                f"Orchestrator cannot satisfy requirements for {strategy.name}:\n"
                f"Required: {requirements}\n"
                f"Available: {orchestrator_capabilities}"
            )
        
        return strategy
```

**å…³é”®å˜åŒ–**:
1. æ¥æ”¶å¼ºç±»å‹StrategyConfigï¼ˆä¸æ˜¯dictï¼‰
2. åˆ©ç”¨isinstance dispatchï¼ˆç±»å‹å®‰å…¨ï¼‰
3. æ–°å¢create_with_validationï¼ˆfail-fastï¼‰
4. é€’å½’åˆ›å»ºMetaStrategyçš„base strategies

---

### è¿ç§»ç­–ç•¥

**é˜¶æ®µ1: å®šä¹‰Schemasï¼ˆå‘åå…¼å®¹ï¼‰**
```
Week 3 Day 1:
- å®šä¹‰æ‰€æœ‰Pydantic schemas
- ç¼–å†™validators
- å®šä¹‰presets

æµ‹è¯•:
- ç”¨ç°æœ‰YAML configsæµ‹è¯•èƒ½å¦parse
- ç¡®ä¿validationæ­£ç¡®
```

**é˜¶æ®µ2: æ›´æ–°ConfigLoaderï¼ˆå…¼å®¹é˜¶æ®µï¼‰**
```
Week 3 Day 2:
- æ›´æ–°ConfigLoaderæ”¯æŒPydantic
- ä¿ç•™load_dict()æ–¹æ³•ï¼ˆè¿”å›dictï¼Œå‘åå…¼å®¹ï¼‰
- æ–°å¢load()æ–¹æ³•ï¼ˆè¿”å›RootConfigï¼‰

å…¼å®¹æœºåˆ¶:
if user_code_uses_dict:
    config_dict = config_loader.load_dict(path)  # æ—§æ¥å£
else:
    config = config_loader.load(path)  # æ–°æ¥å£
```

**é˜¶æ®µ3: æ›´æ–°Factoryï¼ˆå¹¶è¡Œè¿è¡Œï¼‰**
```
Week 3 Day 3:
- StrategyFactoryæ”¯æŒä¸¤ç§è¾“å…¥ï¼ˆdictæˆ–StrategyConfigï¼‰
- æ ¹æ®è¾“å…¥ç±»å‹é€‰æ‹©å¤„ç†é€»è¾‘

def create_from_config(config: Union[dict, StrategyConfig]):
    if isinstance(config, dict):
        # æ—§è·¯å¾„: å…ˆvalidateæˆStrategyConfig
        config = StrategyConfig(**config)
    # æ–°è·¯å¾„: ç›´æ¥ä½¿ç”¨
    ...
```

**é˜¶æ®µ4: å…¨é¢åˆ‡æ¢ï¼ˆåˆ é™¤å…¼å®¹ä»£ç ï¼‰**
```
Week 3 Day 4-5:
- æ›´æ–°æ‰€æœ‰è°ƒç”¨å¤„ä½¿ç”¨æ–°æ¥å£
- åˆ é™¤dict-basedçš„å…¼å®¹ä»£ç 
- è¿è¡Œå®Œæ•´æµ‹è¯•
```

---

## **Layer 4: Orchestrator & Backtestingé›†æˆ**

### ç›®æ ‡
å°†å‰é¢çš„æ”¹é€ é›†æˆåˆ°orchestratorå’Œbacktestingæ¡†æ¶ï¼Œå½¢æˆend-to-endçš„é…ç½®é©±åŠ¨ç³»ç»Ÿã€‚

### æ¶‰åŠæ–‡ä»¶
```
ä¿®æ”¹:
- src/trading_system/orchestration/orchestrator.py
- src/trading_system/backtesting/backtest_engine.py
- src/trading_system/backtesting/metrics_calculator.py

æ–°å¢:
- src/trading_system/orchestration/context.py (CompetitionContext)
- src/trading_system/backtesting/experiment_runner.py
```

### æ”¹é€ å†…å®¹

#### **1. CompetitionContextä½œä¸ºä¾èµ–æ³¨å…¥**

**Context**:
å½“å‰competition constraintsï¼ˆå¦‚rebalance_frequency, transaction costsï¼‰æ˜¯éšå¼çš„æˆ–hardcodedã€‚

**æ”¹é€ è¦ç‚¹**:
- å®šä¹‰CompetitionContextç±»
- é€šè¿‡dependency injectionä¼ é€’
- å½±å“portfolio constructionå’Œperformance evaluation

**CompetitionContextè®¾è®¡**:
```
CompetitionContext (Pydantic BaseModel)
â”œâ”€ objective: Literal['total_return', 'sharpe', 'max_drawdown']
â”œâ”€ rebalance_frequency: Literal['daily', 'weekly', 'monthly']
â”œâ”€ transaction_costs: TransactionCostsConfig
â”œâ”€ universe: UniverseConfig
â”œâ”€ constraints: ConstraintsConfig
â””â”€ evaluation: EvaluationConfig

TransactionCostsConfig (Pydantic BaseModel)
â”œâ”€ cost_per_trade_bps: float  # æ¯ç¬”äº¤æ˜“æˆæœ¬ï¼ˆåŸºç‚¹ï¼‰
â”œâ”€ min_trade_size: float  # æœ€å°äº¤æ˜“é‡‘é¢
â””â”€ slippage_model: Literal['fixed', 'volume_dependent']

UniverseConfig (Pydantic BaseModel)
â”œâ”€ type: Literal['static', 'dynamic']
â”œâ”€ selection_method: str  # 'top_N_by_market_cap'
â”œâ”€ size: int  # 500
â”œâ”€ rebalance_universe_frequency: Optional[str]
â””â”€ filters: List[str]  # ['min_price_5', 'min_volume_1M']

ConstraintsConfig (Pydantic BaseModel)
â”œâ”€ long_only: bool = True
â”œâ”€ max_position_weight: float = 0.10
â”œâ”€ max_sector_weight: Optional[float] = None
â”œâ”€ max_turnover: Optional[float] = None
â””â”€ leverage_limit: float = 1.0
```

**å¦‚ä½•ä½¿ç”¨**:
```
Orchestratoråˆå§‹åŒ–:
def __init__(self, config: RootConfig):
    self.competition_context = CompetitionContext(
        **config.competition
    )
    self.strategies = self._create_strategies(config.strategies)

Portfolio Constructionä½¿ç”¨context:
def optimize_portfolio(
    signals: pd.Series,
    metadata: SignalMetadata,
    context: CompetitionContext
) -> pd.Series:
    # æ ¹æ®contextè°ƒæ•´ä¼˜åŒ–ç›®æ ‡
    if context.objective == 'total_return':
        objective = maximize_return
    elif context.objective == 'sharpe':
        objective = maximize_sharpe
    
    # åº”ç”¨constraints
    constraints = [
        sum(weights) == 1,
        weights >= 0 if context.constraints.long_only else -inf,
        weights <= context.constraints.max_position_weight
    ]
    
    # è€ƒè™‘transaction costs
    if context.transaction_costs:
        turnover_penalty = calculate_turnover_penalty(
            new_weights, 
            old_weights,
            context.transaction_costs
        )
        objective -= turnover_penalty
    
    return optimize(objective, constraints)
```

**è®¾è®¡ç†ç”±**:
- æ˜¾å¼åŒ–: competitionè§„åˆ™ä¸å†éšå¼
- å¯é…ç½®: æ”¹å˜competitionåªéœ€æ”¹config
- å¯æµ‹è¯•: å®¹æ˜“æµ‹è¯•ä¸åŒscenarios

---

#### **2. Orchestratorçš„å®Œæ•´æ•°æ®æµ**

**Context**:
å½“å‰orchestratorçš„_prepare_pipeline_data()ä¸å¤Ÿrobustï¼Œéœ€è¦å®Œæ•´çš„validationå’Œerror handlingã€‚

**æ”¹é€ è¦ç‚¹**:
- æ ¹æ®strategiesçš„requirementså‡†å¤‡æ•°æ®
- Validateèƒ½å¦æ»¡è¶³requirements
- æ¸…æ™°çš„error messages

**å®Œæ•´æµç¨‹**:
```
Orchestrator.run()æµç¨‹:

1. Initialization:
   - åŠ è½½config (RootConfig)
   - åˆ›å»ºcompetition_context
   - åˆ›å»ºæ‰€æœ‰strategies
   - æ”¶é›†æ‰€æœ‰strategiesçš„data_requirements
   - éªŒè¯è‡ªèº«capabilitiesèƒ½å¦æ»¡è¶³requirements

2. æ•°æ®å‡†å¤‡é˜¶æ®µ:
   for each rebalance_date:
       # 2.1 å‡†å¤‡universe
       universe = self._prepare_universe(
           rebalance_date,
           competition_context.universe
       )
       
       # 2.2 è·å–price data
       price_data = self.price_provider.get_prices(
           symbols=universe,
           start_date=...,
           end_date=rebalance_date
       )
       
       # 2.3 æ¡ä»¶å‡†å¤‡factor data
       factor_data = None
       if any(req.requires_factor_data for req in requirements):
           if not self.factor_provider:
               raise MissingProviderError("factor_data required but no provider")
           factor_data = self.factor_provider.get_factors(
               start_date=...,
               end_date=rebalance_date
           )
       
       # 2.4 ç»„è£…PipelineData
       pipeline_data = PipelineData(
           price_data=price_data,
           factor_data=factor_data,
           metadata={...}
       )
       
       # 2.5 Validate
       for strategy in self.strategies:
           strategy_req = strategy.get_data_requirements()
           if not pipeline_data.satisfies(strategy_req):
               raise DataValidationError(
                   f"PipelineData doesn't satisfy requirements for {strategy.name}"
               )

3. ä¿¡å·ç”Ÿæˆé˜¶æ®µ:
   signals_dict = {}
   metadata_dict = {}
   
   for strategy in self.strategies:
       signals, metadata = strategy.generate_signals(pipeline_data)
       signals_dict[strategy.name] = signals
       metadata_dict[strategy.name] = metadata

4. Portfolio Construction:
   # å¦‚æœæ˜¯å•ç­–ç•¥ï¼Œç›´æ¥ç”¨signals
   # å¦‚æœæ˜¯MetaStrategyï¼Œå·²ç»åœ¨generate_signalsä¸­ç»„åˆäº†
   final_signals = signals_dict[primary_strategy.name]
   final_metadata = metadata_dict[primary_strategy.name]
   
   positions = self.portfolio_optimizer.optimize(
       final_signals,
       final_metadata,
       self.competition_context,
       previous_positions  # ç”¨äºè®¡ç®—turnover
   )

5. æ€§èƒ½æ›´æ–°é˜¶æ®µ:
   # ç­‰åˆ°ä¸‹ä¸€æœŸï¼Œè§‚æµ‹realized returns
   realized_returns = self._calculate_realized_returns(
       positions,
       rebalance_date,
       next_rebalance_date
   )
   
   # æ›´æ–°strategiesçš„performance tracker
   for strategy in self.strategies:
       if hasattr(strategy, 'update_performance'):
           strategy.update_performance(
               rebalance_date,
               realized_returns
           )
```

**é”™è¯¯å¤„ç†**:
```
try:
    orchestrator.run()
except MissingProviderError as e:
    logger.error(
        f"Configuration error: {e}\n"
        f"Solution: Add factor_data_provider to config"
    )
    sys.exit(1)
except DataValidationError as e:
    logger.error(
        f"Data validation failed: {e}\n"
        f"Check if data providers are working correctly"
    )
    sys.exit(1)
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    sys.exit(1)
```

**è®¾è®¡ç†ç”±**:
- æ—©æœŸvalidation: åœ¨æ•°æ®å‡†å¤‡é˜¶æ®µå°±å‘ç°é—®é¢˜
- æ¸…æ™°çš„error messages: å‘Šè¯‰ç”¨æˆ·å¦‚ä½•fix
- æ¨¡å—åŒ–: æ¯ä¸ªé˜¶æ®µç‹¬ç«‹ï¼Œæ˜“äºæµ‹è¯•

---

#### **3. Backtest Engineæ”¹é€ **

**Context**:
å½“å‰backtestå¯èƒ½ä¸æ”¯æŒupdate_performance()å’Œmetadata trackingã€‚

**æ”¹é€ è¦ç‚¹**:
- æ”¯æŒperformance tracking
- è®°å½•æ‰€æœ‰metadataç”¨äºäº‹ååˆ†æ
- ç”Ÿæˆè¯¦ç»†çš„performance attributionæŠ¥å‘Š

**BacktestEngineæ”¹é€ **:
```
ã€å½“å‰ã€‘
class BacktestEngine:
    def run(self, strategy, start_date, end_date):
        results = []
        for date in trading_dates:
            pipeline_data = self._prepare_data(date)
            signals = strategy.generate_signals(pipeline_data)
            positions = self._optimize(signals)
            results.append(...)
        return results

ã€æ”¹é€ åã€‘
class BacktestEngine:
    def run(
        self,
        config: RootConfig,
        start_date: datetime,
        end_date: datetime
    ) -> BacktestResult:
        # 1. åˆ›å»ºorchestrator
        orchestrator = Orchestrator(config)
        
        # 2. å‡†å¤‡storage
        signal_history = []
        metadata_history = []
        position_history = []
        returns_history = []
        
        # 3. Backtest loop
        dates = self._get_rebalance_dates(
            start_date, 
            end_date,
            config.competition.rebalance_frequency
        )
        
        for i, date in enumerate(dates):
            # 3.1 å‡†å¤‡æ•°æ®
            pipeline_data = orchestrator._prepare_pipeline_data(date)
            
            # 3.2 ç”Ÿæˆsignals
            signals, metadata = orchestrator.generate_signals(pipeline_data)
            
            # 3.3 Portfolio optimization
            prev_positions = position_history[-1] if position_history else None
            positions = orchestrator.optimize_portfolio(
                signals,
                metadata,
                prev_positions
            )
            
            # 3.4 è®¡ç®—è¯¥æœŸæ”¶ç›Š
            if i < len(dates) - 1:
                next_date = dates[i + 1]
                period_returns = self._calculate_period_returns(
                    positions,
                    date,
                    next_date
                )
                returns_history.append(period_returns)
                
                # 3.5 æ›´æ–°performance tracker
                realized_returns = self._get_realized_returns(date, next_date)
                orchestrator.update_performance(date, realized_returns)
            
            # 3.6 è®°å½•
            signal_history.append((date, signals))
            metadata_history.append((date, metadata))
            position_history.append((date, positions))
        
        # 4. ç”ŸæˆBacktestResult
        return BacktestResult(
            config=config,
            signal_history=signal_history,
            metadata_history=metadata_history,
            position_history=position_history,
            returns_history=returns_history,
            performance_metrics=self._calculate_metrics(returns_history),
            attribution=self._generate_attribution(
                signal_history,
                metadata_history,
                returns_history
            )
        )
```

**BacktestResultç»“æ„**:
```
BacktestResult (Pydantic BaseModel)
â”œâ”€ config: RootConfig  # å®Œæ•´é…ç½®ï¼Œä¾¿äºå¤ç°
â”œâ”€ signal_history: List[Tuple[datetime, pd.Series]]
â”œâ”€ metadata_history: List[Tuple[datetime, SignalMetadata]]
â”œâ”€ position_history: List[Tuple[datetime, pd.Series]]
â”œâ”€ returns_history: List[PeriodReturn]
â”œâ”€ performance_metrics: PerformanceMetrics
â””â”€ attribution: AttributionAnalysis

PerformanceMetrics (Pydantic BaseModel)
â”œâ”€ total_return: float
â”œâ”€ annualized_return: float
â”œâ”€ sharpe_ratio: float
â”œâ”€ max_drawdown: float
â”œâ”€ win_rate: float
â”œâ”€ avg_turnover: float
â””â”€ transaction_cost_drag: float

AttributionAnalysis (Pydantic BaseModel)
â”œâ”€ signal_quality_evolution: pd.DataFrame  # IC over time
â”œâ”€ component_contribution: Dict[str, float]  # å¦‚æœæ˜¯MetaStrategy
â”œâ”€ sector_attribution: pd.DataFrame
â””â”€ period_attribution: pd.DataFrame  # å“ªäº›periodè´¡çŒ®æœ€å¤š
```

**è®¾è®¡ç†ç”±**:
- å®Œæ•´è®°å½•: æ‰€æœ‰ä¸­é—´ç»“æœéƒ½ä¿å­˜
- å¯å¤ç°: BacktestResultåŒ…å«config
- å¯åˆ†æ: attribution analysisä¾¿äºç†è§£performanceæ¥æº

---

#### **4. ExperimentRunnerå®ç°**

**Context**:
éœ€è¦æ‰¹é‡è¿è¡Œå®éªŒï¼Œæ¯”è¾ƒä¸åŒé…ç½®ã€‚

**æ”¹é€ è¦ç‚¹**:
- è‡ªåŠ¨ç”Ÿæˆå®éªŒé…ç½®
- å¹¶è¡Œè¿è¡Œbacktest
- ç”Ÿæˆå¯¹æ¯”æŠ¥å‘Š

**ExperimentRunnerè®¾è®¡**:
```
class ExperimentRunner:
    def __init__(self, experiment_config: ExperimentConfig):
        self.experiment_config = experiment_config
        self.backtest_engine = BacktestEngine()
    
    def run_all(self) -> ExperimentResults:
        # 1. ç”Ÿæˆæ‰€æœ‰é…ç½®ç»„åˆ
        configs = self._generate_config_combinations()
        logger.info(f"Generated {len(configs)} configurations")
        
        # 2. å¹¶è¡Œè¿è¡Œbacktest
        results = []
        with ProcessPoolExecutor(max_workers=4) as executor:
            futures = [
                executor.submit(self._run_single_backtest, cfg)
                for cfg in configs
            ]
            
            for future in tqdm(as_completed(futures), total=len(futures)):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    logger.error(f"Backtest failed: {e}")
        
        # 3. æ”¶é›†æ‰€æœ‰metrics
        comparison_df = self._collect_metrics(results)
        
        # 4. åˆ†æç»“æœ
        analysis = self._analyze_results(comparison_df, results)
        
        # 5. ä¿å­˜
        output_dir = self.experiment_config.output_dir
        self._save_results(output_dir, comparison_df, analysis, results)
        
        return ExperimentResults(
            comparison_df=comparison_df,
            analysis=analysis,
            detailed_results=results
        )
    
    def _generate_config_combinations(self) -> List[RootConfig]:
        """
        ç”Ÿæˆç¬›å¡å°”ç§¯
        ä¾‹å¦‚: [freq: daily, weekly] Ã— [ic_lookback: 20, 60]
        = 4ä¸ªconfigs
        """
        variations = self.experiment_config.variations
        variation_values = [var.values for var in variations]
        
        configs = []
        for combination in itertools.product(*variation_values):
            # å¤åˆ¶base config
            config = self.experiment_config.base_config.copy(deep=True)
            
            # åº”ç”¨variations
            for var, value in zip(variations, combination):
                self._set_nested_value(config, var.config_path, value)
            
            configs.append(config)
        
        return configs
    
    def _collect_metrics(self, results: List[BacktestResult]) -> pd.DataFrame:
        """
        æ”¶é›†æ‰€æœ‰ç»“æœåˆ°DataFrame
        """
        rows = []
        for result in results:
            row = {
                'config_id': self._config_to_id(result.config),
                **self._extract_variation_params(result.config),
                **result.performance_metrics.dict()
            }
            rows.append(row)
        
        return pd.DataFrame(rows)
    
    def _analyze_results(
        self,
        comparison_df: pd.DataFrame,
        detailed_results: List[BacktestResult]
    ) -> AnalysisReport:
        """
        ç”Ÿæˆåˆ†ææŠ¥å‘Š
        """
        # 1. æ‰¾åˆ°best configs
        best_by_metric = {}
        for metric in self.experiment_config.metrics:
            best_idx = comparison_df[metric].idxmax()
            best_by_metric[metric] = comparison_df.loc[best_idx]
        
        # 2. å‚æ•°sensitivityåˆ†æ
        sensitivity = {}
        for variation in self.experiment_config.variations:
            param_name = variation.name
            grouped = comparison_df.groupby(param_name).agg({
                m: ['mean', 'std'] for m in self.experiment_config.metrics
            })
            sensitivity[param_name] = grouped
        
        # 3. Pareto frontier (trade-off analysis)
        if 'total_return' in comparison_df and 'max_drawdown' in comparison_df:
            pareto_indices = self._find_pareto_frontier(
                comparison_df[['total_return', 'max_drawdown']]
            )
            pareto_configs = comparison_df.iloc[pareto_indices]
        else:
            pareto_configs = None
        
        return AnalysisReport(
            best_by_metric=best_by_metric,
            sensitivity_analysis=sensitivity,
            pareto_configs=pareto_configs
        )
    
    def _save_results(self, output_dir, comparison_df, analysis, results):
        """
        ä¿å­˜æ‰€æœ‰ç»“æœ
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # 1. ä¿å­˜comparison table
        comparison_df.to_csv(output_dir / 'comparison.csv', index=False)
        
        # 2. ä¿å­˜best configs
        for metric, row in analysis.best_by_metric.items():
            config = results[row.name].config
            with open(output_dir / f'best_config_{metric}.yaml', 'w') as f:
                yaml.dump(config.dict(), f)
        
        # 3. ç”Ÿæˆplots
        self._generate_plots(comparison_df, analysis, output_dir / 'plots')
        
        # 4. ç”ŸæˆmarkdownæŠ¥å‘Š
        self._generate_markdown_report(analysis, output_dir / 'report.md')
```

**ä½¿ç”¨ç¤ºä¾‹**:
```
# å®šä¹‰å®éªŒ
experiment = ExperimentConfig(
    name="Rebalance_Frequency_Study",
    base_config=load_config("configs/base.yaml"),
    variations=[
        ConfigVariation(
            name="rebalance_freq",
            config_path="competition.rebalance_frequency",
            values=["daily", "weekly", "monthly"]
        ),
        ConfigVariation(
            name="ic_lookback",
            config_path="strategies.ensemble.combination_config.combiner_params.ic_lookback",
            values=[20, 40, 60]
        )
    ],
    metrics=["total_return", "sharpe_ratio", "max_drawdown", "turnover"],
    output_dir=Path("results/experiment_1")
)

# è¿è¡Œ
runner = ExperimentRunner(experiment)
results = runner.run_all()

# æŸ¥çœ‹ç»“æœ
print(results.comparison_df)
print(f"Best config by Sharpe: {results.analysis.best_by_metric['sharpe_ratio']}")

# ç”Ÿæˆçš„æ–‡ä»¶:
# results/experiment_1/
#   â”œâ”€ comparison.csv
#   â”œâ”€ best_config_total_return.yaml
#   â”œâ”€ best_config_sharpe_ratio.yaml
#   â”œâ”€ plots/
#   â”‚   â”œâ”€ metric_comparison.png
#   â”‚   â”œâ”€ sensitivity_rebalance_freq.png
#   â”‚   â””â”€ pareto_frontier.png
#   â””â”€ report.md
```

**è®¾è®¡ç†ç”±**:
- è‡ªåŠ¨åŒ–: ä¸€æ¬¡å®šä¹‰ï¼Œæ‰¹é‡è¿è¡Œ
- å¹¶è¡ŒåŒ–: åˆ©ç”¨å¤šæ ¸åŠ é€Ÿ
- ç³»ç»ŸåŒ–: æ‰€æœ‰å®éªŒç”¨ç»Ÿä¸€æµç¨‹
- å¯è§†åŒ–: è‡ªåŠ¨ç”Ÿæˆplotså’ŒæŠ¥å‘Š

---

### è°ƒç”¨å¤„æ”¹é€ 

#### **ä¸»ç¨‹åºå…¥å£**

```
ã€å½“å‰ã€‘
# main.py
if __name__ == "__main__":
    config = load_config("config.yaml")
    strategy = create_strategy(config['strategy'])
    orchestrator = Orchestrator(strategy, ...)
    orchestrator.run()

ã€æ”¹é€ åã€‘
# main.py
def main():
    # 1. åŠ è½½é…ç½®ï¼ˆè‡ªåŠ¨validationï¼‰
    try:
        config = ConfigLoader().load("config.yaml")
    except ConfigValidationError as e:
        logger.error(f"Invalid configuration: {e}")
        sys.exit(1)
    
    # 2. æ£€æŸ¥æ˜¯å¦æ˜¯å®éªŒæ¨¡å¼
    if config.experiment:
        # å®éªŒæ¨¡å¼ï¼šæ‰¹é‡è¿è¡Œ
        experiment_config = ExperimentConfig(**config.experiment)
        runner = ExperimentRunner(experiment_config)
        results = runner.run_all()
        print(f"Experiment completed. Results saved to {experiment_config.output_dir}")
    else:
        # å•æ¬¡è¿è¡Œæ¨¡å¼
        backtest_engine = BacktestEngine()
        result = backtest_engine.run(
            config,
            start_date=config.backtesting.start_date,
            end_date=config.backtesting.end_date
        )
        
        # æ‰“å°ç»“æœ
        print(f"Total Return: {result.performance_metrics.total_return:.2%}")
        print(f"Sharpe Ratio: {result.performance_metrics.sharpe_ratio:.2f}")
        
        # ä¿å­˜è¯¦ç»†ç»“æœ
        result.save(Path("results/single_run"))

if __name__ == "__main__":
    main()
```

**å…³é”®å˜åŒ–**:
1. é…ç½®validationè‡ªåŠ¨å‘ç”Ÿ
2. æ”¯æŒå®éªŒæ¨¡å¼å’Œå•æ¬¡æ¨¡å¼
3. æ¸…æ™°çš„é”™è¯¯å¤„ç†
4. ç»“æœè‡ªåŠ¨ä¿å­˜

---

### è¿ç§»ç­–ç•¥

**é˜¶æ®µ1: CompetitionContexté›†æˆï¼ˆç‹¬ç«‹ï¼‰**
```
Week 4 Day 1:
- å®ç°CompetitionContext
- ä¿®æ”¹Orchestratoræ¥å—context
- ä¿®æ”¹PortfolioOptimizerä½¿ç”¨context

æµ‹è¯•:
- ç”¨ä¸åŒcontextè¿è¡Œï¼Œç¡®ä¿behavioræ”¹å˜
```

**é˜¶æ®µ2: Backtest Engineæ”¹é€ ï¼ˆæ ¸å¿ƒï¼‰**
```
Week 4 Day 2:
- å®ç°æ–°çš„BacktestEngine.run()
- æ”¯æŒmetadata tracking
- æ”¯æŒperformance update

æµ‹è¯•:
- å¯¹æ¯”æ–°æ—§engineçš„ç»“æœä¸€è‡´æ€§
```

**é˜¶æ®µ3: ExperimentRunnerå®ç°ï¼ˆé«˜çº§åŠŸèƒ½ï¼‰**
```
Week 4 Day 3:
- å®ç°config combination generation
- å®ç°parallel execution
- å®ç°ç»“æœæ”¶é›†å’Œåˆ†æ

æµ‹è¯•:
- è·‘ä¸€ä¸ªå°å®éªŒï¼ˆ2x2 gridï¼‰
- éªŒè¯å¹¶è¡ŒåŒ–æ­£ç¡®æ€§
```

**é˜¶æ®µ4: é›†æˆæµ‹è¯•ï¼ˆEnd-to-endï¼‰**
```
Week 4 Day 4-5:
- è¿è¡Œå®Œæ•´çš„end-to-end flow
- æµ‹è¯•æ‰€æœ‰features
- æ€§èƒ½ä¼˜åŒ–
- æ–‡æ¡£æ›´æ–°
```

---

## ğŸ“Š æœ€ç»ˆæ•ˆæœå±•ç¤º

### ä½¿ç”¨å‰åå¯¹æ¯”

#### **åœºæ™¯1: æ·»åŠ æ–°ç­–ç•¥**

```
ã€æ”¹é€ å‰ã€‘
1. å†™æ–°Strategyç±»
2. å®ç°_compute_features()
3. å®ç°_get_predictions()
4. ä¿®æ”¹orchestratoræ·»åŠ æ–°çš„data providerï¼ˆå¦‚æœéœ€è¦ï¼‰
5. ä¿®æ”¹factoryæ³¨å†Œæ–°strategy
6. æ‰‹åŠ¨æµ‹è¯•æ˜¯å¦æœ‰data flowé—®é¢˜

æ—¶é—´: ~2å¤©
é£é™©: é«˜ï¼ˆå®¹æ˜“å¿˜è®°æŸä¸ªæ­¥éª¤ï¼‰

ã€æ”¹é€ åã€‘
1. å®šä¹‰æ–°StrategyConfig schemaï¼ˆå¦‚æœæ˜¯æ–°typeï¼‰
2. å†™æ–°Strategyç±»
3. å®ç°get_data_requirements()
4. å®ç°get_signal_characteristics()
5. Factoryè‡ªåŠ¨è¯†åˆ«ï¼ˆé€šè¿‡discriminated unionï¼‰

æ—¶é—´: ~4å°æ—¶
é£é™©: ä½ï¼ˆç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œé…ç½®åŠ è½½æ—¶validateï¼‰
```

---

#### **åœºæ™¯2: æµ‹è¯•ä¸åŒsignalç»„åˆ**

```
ã€æ”¹é€ å‰ã€‘
1. ä¿®æ”¹ä»£ç æ”¹å˜meta_weights
2. é‡æ–°è¿è¡Œbacktest
3. æ‰‹åŠ¨è®°å½•ç»“æœ
4. é‡å¤æ­¥éª¤1-3

æ—¶é—´: æ¯ä¸ªç»„åˆ~30åˆ†é’Ÿï¼Œ10ä¸ªç»„åˆ = 5å°æ—¶
é£é™©: å®¹æ˜“ææ··å“ªä¸ªç»“æœå¯¹åº”å“ªä¸ªé…ç½®

ã€æ”¹é€ åã€‘
1. å†™ä¸€ä¸ªexperiment config YAML
2. è¿è¡Œ: python main.py --experiment experiment.yaml
3. è‡ªåŠ¨ç”Ÿæˆcomparison.csvå’Œplots

æ—¶é—´: 10åˆ†é’Ÿè®¾ç½® + è‡ªåŠ¨è¿è¡Œï¼ˆå¯ä»¥å¹¶è¡Œï¼‰
é£é™©: æ— ï¼ˆæ‰€æœ‰ç»“æœè‡ªåŠ¨å…³è”åˆ°configï¼‰
```

---

#### **åœºæ™¯3: åˆ‡æ¢competition scenario**

```
ã€æ”¹é€ å‰ã€‘
1. æ‰¾åˆ°hardcodedçš„rebalance_frequency
2. æ”¹ä»£ç 
3. æ‰¾åˆ°transaction_costså‡è®¾
4. æ”¹ä»£ç 
5. é‡æ–°è¿è¡Œ
6. Hopeæ²¡æ”¹åå…¶ä»–ä¸œè¥¿

æ—¶é—´: ~1å°æ—¶
é£é™©: é«˜ï¼ˆå¯èƒ½æ”¹æ¼æŸå¤„ï¼‰

ã€æ”¹é€ åã€‘
1. æ”¹config.yamlçš„competition section:
   competition:
     rebalance_frequency: weekly  # ä»monthlyæ”¹ä¸ºweekly
     transaction_costs:
       cost_per_trade_bps: 10  # ä»5æ”¹ä¸º10
2. è¿è¡Œ: python main.py

æ—¶é—´: 2åˆ†é’Ÿ
é£é™©: æ— ï¼ˆconfig validationä¿è¯æ­£ç¡®æ€§ï¼‰
```

---

#### **åœºæ™¯4: Debug "factor dataç¼ºå¤±"é—®é¢˜**

```
ã€æ”¹é€ å‰ã€‘
è¿è¡Œæ—¶:
[ERROR] FF5 requires factor_data!
ï¼ˆç„¶åæ»¡ä¸–ç•Œæ‰¾æ˜¯å“ªé‡Œæ²¡æä¾›factor_dataï¼‰

è°ƒè¯•æ—¶é—´: ~1å°æ—¶

ã€æ”¹é€ åã€‘
é…ç½®åŠ è½½æ—¶:
ConfigValidationError: Strategy 'FF5' requires factor_data 
but orchestration.factor_data_provider not configured.

Solution: Add the following to config.yaml:
  orchestration:
    factor_data_provider:
      type: "kenneth_french"
      ...

å‘ç°æ—¶é—´: 1ç§’ï¼ˆé…ç½®åŠ è½½æ—¶ï¼‰
è§£å†³æ—¶é—´: 2åˆ†é’Ÿï¼ˆæŒ‰æç¤ºæ”¹é…ç½®ï¼‰
```

---

### æœ€ç»ˆæ¶æ„çš„ä¼˜åŠ¿

**1. é…ç½®é©±åŠ¨çš„ä¿¡å·ç”Ÿæˆ**
```yaml
# æµ‹è¯•ä¸åŒalpha sourcesåªéœ€æ”¹é…ç½®
strategies:
  ff5_residual:
    preset: ff5_conservative
    overrides:
      signal_config:
        source: "residual_alpha"
  
  ff5_factor_timing:
    preset: ff5_conservative
    overrides:
      signal_config:
        source: "factor_timing"
```

**2. Metadata-awareç»„åˆ**
```yaml
# MetaStrategyè‡ªåŠ¨æ ¹æ®ICè°ƒæƒ
strategies:
  ensemble:
    type: meta
    base_presets: [ml_default, ff5_residual]
    combination_config:
      combiner_type: ic_weighted
      combiner_params:
        ic_lookback: 60
        adaptive_weights: true
```

**3. å®éªŒé©±åŠ¨çš„ç ”ç©¶**
```yaml
# ä¸€æ¬¡å®šä¹‰ï¼Œæ‰¹é‡æµ‹è¯•
experiment:
  variations:
    - name: signal_source
      config_path: "strategies.ff5.signal_config.source"
      values: [residual_alpha, factor_timing, raw_alpha]
    - name: ic_lookback
      config_path: "strategies.ensemble.combination_config.combiner_params.ic_lookback"
      values: [20, 40, 60]
  # è‡ªåŠ¨ç”Ÿæˆ 3 Ã— 3 = 9ä¸ªå®éªŒ
```

**4. Type-safeçš„æ•°æ®æµ**
```python
# IDEè‡ªåŠ¨è¡¥å…¨ï¼Œç¼–è¯‘æ—¶æ£€æŸ¥
def generate_signals(self, pipeline_data: PipelineData):
    factors = pipeline_data.factor_data.factors  # IDE knows this exists
    # ä¸ä¼šæœ‰KeyErroræˆ–None reference
```

---

## âš ï¸ Breaking Changesæ€»ç»“

### ä¼šå½±å“çš„ä»£ç 

```
1. BaseStrategyæ¥å£
   - generate_signals()è¿”å›å€¼ä»pd.Serieså˜ä¸ºTuple[pd.Series, SignalMetadata]
   å½±å“: æ‰€æœ‰è°ƒç”¨generate_signals()çš„ä»£ç 

2. Pipeline_dataç±»å‹
   - ä»Dict[str, Any]å˜ä¸ºPipelineData
   å½±å“: æ‰€æœ‰æ¥æ”¶pipeline_dataçš„ä»£ç 

3. Configç±»å‹
   - ä»dictå˜ä¸ºPydantic models
   å½±å“: StrategyFactoryå’Œæ‰€æœ‰åŠ è½½é…ç½®çš„ä»£ç 

4. MetaStrategyæ„é€ å‡½æ•°
   - ä»(base_strategies, meta_weights)å˜ä¸º(config, base_strategies)
   å½±å“: åˆ›å»ºMetaStrategyçš„ä»£ç 

5. Backtest Engine
   - run()æ–¹æ³•ç­¾åæ”¹å˜
   å½±å“: è°ƒç”¨backtestçš„ä»£ç 
```

### è¿ç§»è·¯å¾„

æ‰€æœ‰breaking changeséƒ½é€šè¿‡**3é˜¶æ®µè¿ç§»**:
1. æ·»åŠ æ–°æ¥å£ï¼Œä¿ç•™æ—§æ¥å£ï¼ˆå…¼å®¹ï¼‰
2. é€æ­¥è¿ç§»è°ƒç”¨å¤„
3. åˆ é™¤æ—§æ¥å£

---

## ğŸ“… å®Œæ•´æ—¶é—´çº¿

```
Week 1: ç±»å‹ç³»ç»ŸåŸºç¡€ + BaseStrategyæ”¹é€ 
â”œâ”€ Day 1-2: å®šä¹‰PipelineData, SignalMetadata, DataRequirements
â”œâ”€ Day 3-4: æ”¹é€ BaseStrategyæ¥å£
â””â”€ Day 5: è¿ç§»MLStrategy, FF5Strategy, FF3Strategy

Week 2: MetaStrategyæ™ºèƒ½ç»„åˆ
â”œâ”€ Day 1: å®ç°Combineræ¡†æ¶
â”œâ”€ Day 2-3: å®ç°ICWeightedCombiner
â”œâ”€ Day 4: é‡æ„MetaStrategy
â””â”€ Day 5: é›†æˆåˆ°backtest loop

Week 3: Configurationç³»ç»Ÿ
â”œâ”€ Day 1: å®šä¹‰Pydantic schemas
â”œâ”€ Day 2: æ›´æ–°ConfigLoader
â”œâ”€ Day 3: æ›´æ–°StrategyFactory
â””â”€ Day 4-5: å®ç°presetså’Œå…¨é¢æµ‹è¯•

Week 4: Orchestrator & Backtesting
â”œâ”€ Day 1: CompetitionContexté›†æˆ
â”œâ”€ Day 2: Backtest Engineæ”¹é€ 
â”œâ”€ Day 3: ExperimentRunnerå®ç°
â””â”€ Day 4-5: End-to-endæµ‹è¯•å’Œæ–‡æ¡£

æ€»è®¡: 20ä¸ªå·¥ä½œæ—¥ (4å‘¨)
```

---
## âœ… éªŒæ”¶æ ‡å‡†ï¼ˆç»­ï¼‰

å®Œæˆååº”è¯¥èƒ½å¤Ÿ:

1. âœ… æ·»åŠ æ–°strategyåªéœ€å†™é…ç½® + å®ç°2ä¸ªæ–¹æ³•ï¼ˆget_data_requirements, get_signal_characteristicsï¼‰
2. âœ… åˆ‡æ¢ä¸åŒsignal sourcesï¼ˆresidual vs factor timingï¼‰åªéœ€æ”¹config
3. âœ… MetaStrategyæ ¹æ®ICè‡ªåŠ¨è°ƒæƒï¼Œæ— éœ€æ‰‹åŠ¨æŒ‡å®š
4. âœ… é…ç½®é”™è¯¯åœ¨åŠ è½½æ—¶å‘ç°ï¼Œè€Œä¸æ˜¯è¿è¡Œæ—¶crash
5. âœ… IDEæä¾›å®Œæ•´çš„ç±»å‹æç¤ºå’Œè‡ªåŠ¨è¡¥å…¨
6. âœ… è¿è¡Œå®éªŒåªéœ€ä¸€æ¡å‘½ä»¤ï¼Œè‡ªåŠ¨ç”Ÿæˆå¯¹æ¯”æŠ¥å‘Š
7. âœ… Pipeline_dataçš„æ•°æ®ä¾èµ–æ˜¾å¼å£°æ˜ï¼Œorchestratorè‡ªåŠ¨éªŒè¯
8. âœ… Signal metadataè‡ªåŠ¨è®¡ç®—å¹¶ä¼ é€’ï¼Œæ— éœ€æ‰‹åŠ¨ç®¡ç†
9. âœ… å¯ä»¥é€šè¿‡configåœ¨ä¸åŒcompetition scenariosé—´åˆ‡æ¢
10. âœ… æ‰€æœ‰backtestç»“æœå¯è¿½æº¯åˆ°ç²¾ç¡®çš„config

---

## ğŸ” å…³é”®è®¾è®¡å†³ç­–å›é¡¾

### **å†³ç­–1: ä¸ºä»€ä¹ˆç”¨Pydanticè€Œä¸æ˜¯TypedDictï¼Ÿ**

**ç†ç”±**:
```
TypedDictä¼˜åŠ¿:
- è½»é‡ï¼Œåªæ˜¯ç±»å‹æ ‡æ³¨
- ä¸æ”¹å˜runtime behavior

TypedDictåŠ£åŠ¿:
- æ²¡æœ‰validation
- æ²¡æœ‰default values
- ä¸æ”¯æŒåµŒå¥—validation
- ä¸æ”¯æŒcomputed fields

Pydanticä¼˜åŠ¿:
- è‡ªåŠ¨validationï¼ˆè¿™æ˜¯æˆ‘ä»¬æœ€éœ€è¦çš„ï¼‰
- æ”¯æŒå¤æ‚åµŒå¥—ç»“æ„
- JSON schemaç”Ÿæˆï¼ˆå¯ä»¥ç»™å‰ç«¯ç”¨ï¼‰
- ä¸°å¯Œçš„validatorè£…é¥°å™¨

PydanticåŠ£åŠ¿:
- æœ‰runtime overheadï¼ˆä½†å¯¹æˆ‘ä»¬çš„ç”¨ä¾‹å¯å¿½ç•¥ï¼‰
- éœ€è¦é¢å¤–ä¾èµ–

ç»“è®º: Pydanticçš„validationä»·å€¼è¿œè¶…å…¶overhead
```

---

### **å†³ç­–2: Signal metadataåº”è¯¥åœ¨generate_signals()æ—¶è®¡ç®—ï¼Œè¿˜æ˜¯äº‹åè®¡ç®—ï¼Ÿ**

**é€‰æ‹©: generate_signals()æ—¶è®¡ç®—**

**ç†ç”±**:
```
generate_signals()æ—¶è®¡ç®—:
ä¼˜åŠ¿:
- ç­–ç•¥æœ€äº†è§£è‡ªå·±çš„signalç‰¹æ€§
- å¯ä»¥ä½¿ç”¨å†…éƒ¨çŠ¶æ€ï¼ˆå¦‚regressionç»“æœï¼‰æä¾›æ›´å‡†ç¡®çš„ä¼°è®¡
- å¼ºåˆ¶ç­–ç•¥å¼€å‘è€…æ€è€ƒsignal quality
- Metadataä¸signalsåœ¨åŒä¸€æ—¶åˆ»ç”Ÿæˆï¼Œä¿è¯ä¸€è‡´æ€§

åŠ£åŠ¿:
- å¢åŠ generate_signals()çš„è®¡ç®—è´Ÿæ‹…
- å¯èƒ½æ‹–æ…¢signal generation

äº‹åè®¡ç®—:
ä¼˜åŠ¿:
- ä¸å½±å“signal generationé€Ÿåº¦
- å¯ä»¥ç”¨ç»Ÿä¸€çš„ç®—æ³•è®¡ç®—æ‰€æœ‰strategiesçš„metadata

åŠ£åŠ¿:
- æ— æ³•åˆ©ç”¨ç­–ç•¥å†…éƒ¨ä¿¡æ¯ï¼ˆå¦‚FF5çš„regression RÂ²ï¼‰
- éœ€è¦é¢å¤–çš„infrastructureè¿½è¸ªsignalså†å²
- Metadataå¯èƒ½ä¸signalsä¸ä¸€è‡´ï¼ˆå¦‚æœå¼‚æ­¥è®¡ç®—ï¼‰

ç»“è®º: å‡†ç¡®æ€§ > é€Ÿåº¦ï¼Œä¸”è®¡ç®—metadataçš„overheadä¸å¤§
```

---

### **å†³ç­–3: MetaStrategyåº”è¯¥åœ¨å†…éƒ¨ç»„åˆsignalsï¼Œè¿˜æ˜¯è¿”å›å¤šä¸ªsignalsè®©å¤–éƒ¨ç»„åˆï¼Ÿ**

**é€‰æ‹©: å†…éƒ¨ç»„åˆ**

**ç†ç”±**:
```
å†…éƒ¨ç»„åˆ:
ä¼˜åŠ¿:
- ç»„åˆé€»è¾‘å°è£…åœ¨MetaStrategyä¸­ï¼Œç¬¦åˆOOPåŸåˆ™
- å¯¹å¤–æ¥å£ç»Ÿä¸€ï¼ˆéƒ½æ˜¯generate_signalsè¿”å›tupleï¼‰
- ä¾¿äºç»´æŠ¤ç»„åˆç›¸å…³çš„çŠ¶æ€ï¼ˆå¦‚IC historyï¼‰

åŠ£åŠ¿:
- çµæ´»æ€§ç¨å·®ï¼ˆå¤–éƒ¨æ— æ³•ç›´æ¥è®¿é—®base signalsï¼‰

å¤–éƒ¨ç»„åˆ:
ä¼˜åŠ¿:
- æ›´çµæ´»ï¼Œå¯ä»¥åœ¨orchestratorå±‚é¢åšæ›´å¤æ‚çš„ç»„åˆ
- ä¾¿äºdebuggingï¼ˆå¯ä»¥å•ç‹¬çœ‹æ¯ä¸ªbase signalï¼‰

åŠ£åŠ¿:
- æ‰“ç ´äº†strategyçš„æŠ½è±¡
- Orchestratoréœ€è¦çŸ¥é“å“ªäº›strategieséœ€è¦ç»„åˆ
- çŠ¶æ€ç®¡ç†å¤æ‚ï¼ˆIC historyæ”¾å“ªï¼Ÿï¼‰

ç»“è®º: å°è£…æ€§ > çµæ´»æ€§ï¼Œä¸”debuggingå¯ä»¥é€šè¿‡logging base signalså®ç°
```

---

### **å†³ç­–4: ExperimentRunneråº”è¯¥å¹¶è¡Œè¿è¡Œè¿˜æ˜¯ä¸²è¡Œï¼Ÿ**

**é€‰æ‹©: æ”¯æŒå¹¶è¡Œï¼Œé»˜è®¤è‡ªåŠ¨æ£€æµ‹**

**ç†ç”±**:
```
å¹¶è¡Œè¿è¡Œ:
ä¼˜åŠ¿:
- æ˜¾è‘—åŠ é€Ÿï¼ˆ4æ ¸å¯ä»¥4xé€Ÿåº¦ï¼‰
- å……åˆ†åˆ©ç”¨ç¡¬ä»¶èµ„æº

åŠ£åŠ¿:
- å®ç°å¤æ‚åº¦é«˜
- éœ€è¦å¤„ç†è¿›ç¨‹é—´æ•°æ®ä¼ è¾“
- å¯èƒ½æœ‰å†…å­˜é—®é¢˜ï¼ˆå¦‚æœåŒæ—¶åŠ è½½å¤šä¸ªå¤§æ•°æ®é›†ï¼‰

ä¸²è¡Œè¿è¡Œ:
ä¼˜åŠ¿:
- å®ç°ç®€å•
- å†…å­˜å¯æ§
- ä¾¿äºdebugging

åŠ£åŠ¿:
- æ…¢ï¼ˆ10ä¸ªå®éªŒä¸²è¡Œå¯èƒ½éœ€è¦æ•°å°æ—¶ï¼‰

å®ç°ç­–ç•¥:
- ä½¿ç”¨ProcessPoolExecutorï¼ˆè€ŒéThreadPoolExecutorï¼Œå› ä¸ºbacktestæ˜¯CPUå¯†é›†ï¼‰
- è‡ªåŠ¨æ£€æµ‹CPUæ ¸æ•°
- æä¾›å‚æ•°æ§åˆ¶å¹¶è¡Œåº¦ï¼ˆmax_workersï¼‰
- å¦‚æœæŸä¸ªbacktestå†…å­˜éœ€æ±‚å¤§ï¼Œè‡ªåŠ¨é™ä½å¹¶è¡Œåº¦

ç»“è®º: å¹¶è¡Œæ˜¯å¿…é¡»çš„ï¼Œä½†è¦åšå¥½èµ„æºç®¡ç†
```

---

### **å†³ç­–5: CompetitionContextåº”è¯¥æ˜¯å…¨å±€çš„è¿˜æ˜¯ä½œä¸ºå‚æ•°ä¼ é€’ï¼Ÿ**

**é€‰æ‹©: ä½œä¸ºå‚æ•°ä¼ é€’ï¼ˆä¾èµ–æ³¨å…¥ï¼‰**

**ç†ç”±**:
```
å…¨å±€å˜é‡:
ä¼˜åŠ¿:
- æ–¹ä¾¿è®¿é—®ï¼Œä»»ä½•åœ°æ–¹éƒ½èƒ½ç”¨
- ä¸éœ€è¦åœ¨å‡½æ•°ç­¾åä¸­ä¼ æ¥ä¼ å»

åŠ£åŠ¿:
- æµ‹è¯•å›°éš¾ï¼ˆéœ€è¦mockå…¨å±€çŠ¶æ€ï¼‰
- å¹¶è¡Œè¿è¡Œæ—¶æœ‰race conditioné£é™©
- è¿åå‡½æ•°å¼ç¼–ç¨‹åŸåˆ™ï¼ˆside effectsï¼‰
- éš¾ä»¥æ”¯æŒå¤šä¸ªcontextåŒæ—¶å­˜åœ¨

ä¾èµ–æ³¨å…¥:
ä¼˜åŠ¿:
- æ˜¾å¼ä¾èµ–ï¼Œä»£ç æ›´æ¸…æ™°
- ä¾¿äºæµ‹è¯•ï¼ˆç›´æ¥ä¼ å…¥mockï¼‰
- æ”¯æŒå¹¶è¡Œè¿è¡Œä¸åŒcontext
- ç¬¦åˆSOLIDåŸåˆ™ï¼ˆä¾èµ–å€’ç½®ï¼‰

åŠ£åŠ¿:
- éœ€è¦åœ¨å‡½æ•°ç­¾åä¸­ä¼ é€’
- ç¨å¾®å¢åŠ ä»£ç é‡

ç»“è®º: ä¾èµ–æ³¨å…¥æ˜¯æ­£ç¡®çš„æ¶æ„é€‰æ‹©ï¼Œå…¨å±€å˜é‡åªä¼šå¸¦æ¥æŠ€æœ¯å€º
```

---

## ğŸ“ æ¶æ„æ¨¡å¼æ€»ç»“

è¿™æ¬¡é‡æ„åº”ç”¨äº†ä»¥ä¸‹è®¾è®¡æ¨¡å¼:

### **1. Strategy Pattern (ç­–ç•¥æ¨¡å¼)**
```
åº”ç”¨åœºæ™¯:
- BaseCombineråŠå…¶å­ç±»ï¼ˆFixedWeight, ICWeighted, Adaptiveï¼‰
- FeaturePipelineçš„ä¸åŒå®ç°

å¥½å¤„:
- è¿è¡Œæ—¶åˆ‡æ¢ç®—æ³•
- æ–°å¢ç®—æ³•ä¸å½±å“ç°æœ‰ä»£ç 
- é€šè¿‡é…ç½®é€‰æ‹©ç­–ç•¥
```

### **2. Factory Pattern (å·¥å‚æ¨¡å¼)**
```
åº”ç”¨åœºæ™¯:
- StrategyFactory.create_from_config()
- CombinerFactory.create()
- FeaturePipelineFactory.create()

å¥½å¤„:
- é›†ä¸­åˆ›å»ºé€»è¾‘
- éšè—å…·ä½“ç±»å‹
- ä¾¿äºæ‰©å±•ï¼ˆæ³¨å†Œæ–°ç±»å‹ï¼‰
```

### **3. Dependency Injection (ä¾èµ–æ³¨å…¥)**
```
åº”ç”¨åœºæ™¯:
- CompetitionContextæ³¨å…¥åˆ°Orchestrator
- PipelineDataæ³¨å…¥åˆ°Strategy
- SignalMetadataä¼ é€’ç»™Combiner

å¥½å¤„:
- æ¾è€¦åˆ
- ä¾¿äºæµ‹è¯•
- æ˜¾å¼ä¾èµ–
```

### **4. Template Method (æ¨¡æ¿æ–¹æ³•)**
```
åº”ç”¨åœºæ™¯:
- BaseStrategy.generate_signals()å®šä¹‰æµç¨‹
- å­ç±»å®ç°_compute_features(), _get_predictions()ç­‰hook

å¥½å¤„:
- ç»Ÿä¸€æµç¨‹
- å­ç±»åªéœ€å®ç°å·®å¼‚éƒ¨åˆ†
- ä¾¿äºæ·»åŠ æ¨ªåˆ‡å…³æ³¨ç‚¹ï¼ˆå¦‚loggingï¼‰
```

### **5. Observer Pattern (è§‚å¯Ÿè€…æ¨¡å¼)**
```
åº”ç”¨åœºæ™¯:
- PerformanceTrackerè§‚å¯Ÿrealized returns
- MetaStrategyæ ¹æ®performanceæ›´æ–°æƒé‡

å¥½å¤„:
- è§£è€¦performance trackingå’Œsignal generation
- æ”¯æŒå¤šä¸ªobserversï¼ˆå¯ä»¥åŒæ—¶è®°å½•å¤šç§metricsï¼‰
```

### **6. Builder Pattern (å»ºé€ è€…æ¨¡å¼)**
```
åº”ç”¨åœºæ™¯:
- ExperimentRunneræ„å»ºå®éªŒé…ç½®
- ConfigLoaderè§£æå’Œæ„å»ºRootConfig

å¥½å¤„:
- å¤æ‚å¯¹è±¡çš„åˆ†æ­¥æ„å»º
- æ”¯æŒpreset + overrideæ¨¡å¼
```

---

## ğŸš§ æ½œåœ¨é™·é˜±ä¸å¯¹ç­–

### **é™·é˜±1: Pydantic validationçš„æ€§èƒ½å½±å“**

**é—®é¢˜**:
```
åœ¨tight loopä¸­é¢‘ç¹åˆ›å»ºPydantic modelså¯èƒ½æœ‰æ€§èƒ½é—®é¢˜
ä¾‹å¦‚: æ¯ä¸ªrebalance_dateéƒ½åˆ›å»ºPipelineData
```

**å¯¹ç­–**:
```
1. ä½¿ç”¨Pydanticçš„Config.validate_assignment = Falseï¼ˆå¦‚æœä¸éœ€è¦runtime validationï¼‰
2. åœ¨å…³é”®è·¯å¾„ä¸Šreuse objectsè€Œéé‡æ–°åˆ›å»º
3. ä½¿ç”¨Pydanticçš„construct()æ–¹æ³•è·³è¿‡validationï¼ˆå¦‚æœç¡®å®šæ•°æ®åˆæ³•ï¼‰

ç¤ºä¾‹:
# æ…¢
for date in dates:
    pipeline_data = PipelineData(price_data=..., factor_data=...)

# å¿«
for date in dates:
    pipeline_data = PipelineData.construct(
        price_data=..., 
        factor_data=...,
        _fields_set={'price_data', 'factor_data'}
    )
```

**ä½•æ—¶ä¼˜åŒ–**:
- å…ˆå®ç°åŠŸèƒ½ï¼Œä¸è¦è¿‡æ—©ä¼˜åŒ–
- å¦‚æœprofilingæ˜¾ç¤ºPydantic validationæ˜¯ç“¶é¢ˆï¼Œå†ä¼˜åŒ–
- é€šå¸¸ä¸æ˜¯é—®é¢˜ï¼ˆvalidationæ—¶é—´ << backtestè®¡ç®—æ—¶é—´ï¼‰

---

### **é™·é˜±2: SignalMetadataçš„ICä¼°è®¡ä¸å‡†ç¡®**

**é—®é¢˜**:
```
å¦‚æœstrategyæä¾›çš„expected_icä¸realized_icå·®å¼‚å¤§ï¼Œ
ICWeightedCombinerçš„æƒé‡ä¼šä¸å‡†ç¡®
```

**å¯¹ç­–**:
```
1. åˆæœŸä½¿ç”¨priorï¼ˆæ–‡çŒ®å€¼æˆ–ä¿å®ˆä¼°è®¡ï¼‰
2. ç§¯ç´¯è¶³å¤Ÿå†å²åï¼Œé€æ¸å¢åŠ realized_icçš„æƒé‡
3. æ£€æµ‹ICçš„regime changeï¼ˆå¦‚æœICçªç„¶ä¸‹é™ï¼Œå¿«é€Ÿè°ƒæ•´ï¼‰

å®ç°:
class ICWeightedCombiner:
    def _compute_weights(self, metadata_dict, performance_history):
        weights = {}
        for name, metadata in metadata_dict.items():
            # è®¡ç®—å†å²æ•°æ®å……åˆ†åº¦
            history_length = len(performance_history[name])
            confidence = min(1.0, history_length / self.config.min_history)
            
            # åŠ æƒç»„åˆpriorå’Œrealized
            prior_ic = metadata.quality_metrics.expected_ic
            realized_ic = performance_history[name]['ic'].rolling(
                self.config.ic_lookback
            ).mean().iloc[-1]
            
            effective_ic = (
                (1 - confidence) * prior_ic + 
                confidence * realized_ic
            )
            
            weights[name] = max(0, effective_ic)
        
        return self._normalize_weights(weights)
```

---

### **é™·é˜±3: DataRequirementséªŒè¯è¿‡äºä¸¥æ ¼å¯¼è‡´æ— æ³•è¿è¡Œ**

**é—®é¢˜**:
```
å¦‚æœvalidationå¤ªä¸¥æ ¼ï¼Œå¯èƒ½æŸäº›edge casesæ— æ³•å¤„ç†
ä¾‹å¦‚: strategyå£°æ˜éœ€è¦252å¤©å†å²ï¼Œä½†backteståˆæœŸåªæœ‰100å¤©
```

**å¯¹ç­–**:
```
1. Requirementsä¸­åŒºåˆ†hard requirementså’Œsoft requirements
2. æä¾›overrideæœºåˆ¶å…è®¸æ”¾æ¾çº¦æŸ
3. æä¾›clear error messageå‘Šè¯‰ç”¨æˆ·å¦‚ä½•fix

å®ç°:
class DataRequirements:
    requires_factor_data: Optional[FactorDataRequirement]
    
    # æ–°å¢
    allow_partial_data: bool = False  # æ˜¯å¦å…è®¸æ•°æ®ä¸å®Œæ•´
    min_required_history: Optional[int] = None  # ç»å¯¹æœ€å°å€¼
    
def _validate_requirements(self, requirements, pipeline_data):
    if requirements.requires_factor_data:
        if pipeline_data.factor_data is None:
            if requirements.allow_partial_data:
                logger.warning("Factor data missing but allow_partial_data=True")
                return  # å…è®¸ç»§ç»­
            else:
                raise MissingDataError("Factor data required")
        
        # æ£€æŸ¥å†å²é•¿åº¦
        actual_length = len(pipeline_data.factor_data.factors)
        required_length = requirements.requires_factor_data.min_history_days
        
        if actual_length < required_length:
            if requirements.allow_partial_data and actual_length >= requirements.min_required_history:
                logger.warning(f"Only {actual_length} days available, required {required_length}")
                return
            else:
                raise InsufficientDataError(
                    f"Need {required_length} days, only {actual_length} available"
                )
```

---

### **é™·é˜±4: MetaStrategyçš„circular dependency**

**é—®é¢˜**:
```
å¦‚æœMetaStrategyçš„base_strategiesä¸­åŒ…å«å¦ä¸€ä¸ªMetaStrategyï¼Œ
å¯èƒ½å½¢æˆå¾ªç¯ä¾èµ–
```

**å¯¹ç­–**:
```
1. åœ¨config validationæ—¶æ£€æµ‹å¾ªç¯ä¾èµ–
2. é™åˆ¶åµŒå¥—æ·±åº¦ï¼ˆå¦‚æœ€å¤š2å±‚MetaStrategyï¼‰

å®ç°:
class MetaStrategyConfig:
    @root_validator
    def detect_circular_dependency(cls, values):
        base_configs = values.get('base_strategy_configs', [])
        
        # BFSæ£€æµ‹å¾ªç¯
        visited = set()
        queue = [(cfg, 0) for cfg in base_configs]
        
        while queue:
            cfg, depth = queue.pop(0)
            
            if depth > 2:
                raise ValueError("MetaStrategy nesting too deep (max 2 levels)")
            
            cfg_id = id(cfg)
            if cfg_id in visited:
                raise ValueError("Circular dependency detected in MetaStrategy")
            visited.add(cfg_id)
            
            if cfg.type == 'meta':
                for sub_cfg in cfg.base_strategy_configs:
                    queue.append((sub_cfg, depth + 1))
        
        return values
```

---

### **é™·é˜±5: Experimentå¹¶è¡Œè¿è¡Œæ—¶çš„å†…å­˜çˆ†ç‚¸**

**é—®é¢˜**:
```
å¦‚æœå¹¶è¡Œè¿è¡Œå¤šä¸ªbacktestï¼Œæ¯ä¸ªéƒ½åŠ è½½å…¨éƒ¨å†å²æ•°æ®ï¼Œ
å¯èƒ½å¯¼è‡´å†…å­˜ä¸è¶³
```

**å¯¹ç­–**:
```
1. æ•°æ®å…±äº«: ä½¿ç”¨shared memoryè®©å¤šä¸ªè¿›ç¨‹å…±äº«æ•°æ®
2. æ‡’åŠ è½½: åªåœ¨éœ€è¦æ—¶åŠ è½½æ•°æ®ï¼Œç”¨å®Œé‡Šæ”¾
3. åŠ¨æ€è°ƒæ•´å¹¶è¡Œåº¦: ç›‘æ§å†…å­˜ä½¿ç”¨ï¼Œè‡ªåŠ¨å‡å°‘workeræ•°

å®ç°:
class ExperimentRunner:
    def run_all(self):
        # 1. é¢„åŠ è½½å…±äº«æ•°æ®åˆ°shared memory
        shared_data = self._prepare_shared_data()
        
        # 2. åŠ¨æ€è°ƒæ•´å¹¶è¡Œåº¦
        initial_workers = min(cpu_count(), 4)
        
        with ProcessPoolExecutor(max_workers=initial_workers) as executor:
            futures = []
            
            for cfg in configs:
                # æ£€æŸ¥å†…å­˜ä½¿ç”¨
                mem_usage = psutil.virtual_memory().percent
                
                if mem_usage > 80:
                    # ç­‰å¾…ä¸€äº›ä»»åŠ¡å®Œæˆ
                    done, pending = wait(
                        futures, 
                        return_when=FIRST_COMPLETED
                    )
                    for future in done:
                        results.append(future.result())
                    futures = list(pending)
                
                # æäº¤æ–°ä»»åŠ¡
                future = executor.submit(
                    self._run_single_backtest,
                    cfg,
                    shared_data  # ä¼ é€’shared data reference
                )
                futures.append(future)
```

---

## ğŸ“š æ–‡æ¡£ä¸çŸ¥è¯†ä¼ é€’

é‡æ„å®Œæˆåéœ€è¦æ›´æ–°çš„æ–‡æ¡£:

### **1. Architecture Document**
```
å†…å®¹:
- ç³»ç»Ÿæ¶æ„å›¾ï¼ˆå„å±‚å…³ç³»ï¼‰
- æ•°æ®æµå›¾ï¼ˆä»configåˆ°ç»“æœï¼‰
- å…³é”®è®¾è®¡å†³ç­–åŠç†ç”±
- å„ä¸ªç»„ä»¶çš„èŒè´£

ç›®æ ‡è¯»è€…: æ–°åŠ å…¥çš„å¼€å‘è€…

ä½ç½®: docs/architecture.md
```

### **2. Configuration Guide**
```
å†…å®¹:
- æ‰€æœ‰config schemasçš„è¯´æ˜
- å¸¸ç”¨é…ç½®ç¤ºä¾‹
- Presetä½¿ç”¨æŒ‡å—
- å¦‚ä½•å†™experiment config

ç›®æ ‡è¯»è€…: ä½¿ç”¨ç³»ç»Ÿè¿›è¡Œç ”ç©¶çš„äºº

ä½ç½®: docs/configuration_guide.md
```

### **3. Strategy Development Guide**
```
å†…å®¹:
- å¦‚ä½•å®ç°æ–°strategy
- BaseStrategyæ¥å£è¯´æ˜
- DataRequirementså¦‚ä½•å£°æ˜
- SignalMetadataå¦‚ä½•è®¡ç®—
- æœ€ä½³å®è·µå’Œå¸¸è§é™·é˜±

ç›®æ ‡è¯»è€…: å¼€å‘æ–°ç­–ç•¥çš„äºº

ä½ç½®: docs/strategy_development.md
```

### **4. API Reference**
```
å†…å®¹:
- æ‰€æœ‰public classeså’Œmethodsçš„æ–‡æ¡£
- ç”¨sphinxæˆ–mkdocsè‡ªåŠ¨ç”Ÿæˆ

ç›®æ ‡è¯»è€…: éœ€è¦è¯¦ç»†APIä¿¡æ¯çš„å¼€å‘è€…

ä½ç½®: docs/api/
```

### **5. Migration Guide**
```
å†…å®¹:
- ä»æ—§æ¶æ„è¿ç§»åˆ°æ–°æ¶æ„çš„æ­¥éª¤
- Breaking changesæ¸…å•
- ä»£ç ç¤ºä¾‹å¯¹æ¯”ï¼ˆbefore/afterï¼‰
- FAQ

ç›®æ ‡è¯»è€…: éœ€è¦è¿ç§»ç°æœ‰ä»£ç çš„äºº

ä½ç½®: docs/migration_guide.md
```

### **6. Experiment Workflow Tutorial**
```
å†…å®¹:
- ç«¯åˆ°ç«¯çš„å®éªŒworkflowç¤ºä¾‹
- ä»å®šä¹‰é—®é¢˜åˆ°å¾—å‡ºç»“è®º
- å¦‚ä½•è§£é‡Šç»“æœ
- å¦‚ä½•è¿­ä»£æ”¹è¿›

ç›®æ ‡è¯»è€…: ä½¿ç”¨ç³»ç»Ÿåšç ”ç©¶çš„äºº

ä½ç½®: docs/tutorial_experiment_workflow.md
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### **æµ‹è¯•å±‚çº§**

```
1. Unit Tests (å•å…ƒæµ‹è¯•)
   è¦†ç›–:
   - æ‰€æœ‰Pydantic modelsçš„validation
   - Combinerçš„æƒé‡è®¡ç®—é€»è¾‘
   - ICè®¡ç®—é€»è¾‘
   - Configè§£æé€»è¾‘
   
   å·¥å…·: pytest
   ç›®æ ‡è¦†ç›–ç‡: >90%

2. Integration Tests (é›†æˆæµ‹è¯•)
   è¦†ç›–:
   - Strategy + Orchestratoräº¤äº’
   - MetaStrategy + BaseCombineräº¤äº’
   - ConfigLoader + StrategyFactoryé›†æˆ
   
   å·¥å…·: pytest
   ç›®æ ‡è¦†ç›–ç‡: >80%

3. End-to-End Tests (ç«¯åˆ°ç«¯æµ‹è¯•)
   è¦†ç›–:
   - å®Œæ•´backtestæµç¨‹
   - Experiment runneræµç¨‹
   - ä½¿ç”¨ä¸åŒconfigsçš„ç»„åˆ
   
   å·¥å…·: pytest + å°è§„æ¨¡æ•°æ®
   ç›®æ ‡: å…³é”®åœºæ™¯éƒ½æœ‰test case

4. Regression Tests (å›å½’æµ‹è¯•)
   è¦†ç›–:
   - é‡æ„åçš„ç»“æœä¸é‡æ„å‰ä¸€è‡´
   - æ•°å€¼è®¡ç®—çš„æ­£ç¡®æ€§ï¼ˆä¸æ‰‹ç®—å¯¹æ¯”ï¼‰
   
   å·¥å…·: pytest + golden files
```

### **å…³é”®æµ‹è¯•åœºæ™¯**

#### **åœºæ™¯1: Config Validation**
```python
def test_ff5_config_without_factor_provider():
    """æµ‹è¯•FF5 strategyæ²¡æœ‰factor provideræ—¶fail-fast"""
    config = RootConfig(
        strategies={
            'ff5': FF5StrategyConfig(
                name='FF5',
                lookback_window=252
            )
        },
        orchestration=OrchestrationConfig(
            # æ²¡æœ‰factor_data_provider
        )
    )
    
    with pytest.raises(ConfigValidationError) as exc_info:
        orchestrator = Orchestrator(config)
    
    assert "factor_data_provider not configured" in str(exc_info.value)
```

#### **åœºæ™¯2: IC-Weighted Combination**
```python
def test_ic_weighted_combiner_adjusts_weights():
    """æµ‹è¯•IC combineræ ¹æ®realized ICè°ƒæ•´æƒé‡"""
    # Setup
    combiner = ICWeightedCombiner(
        config=ICWeightedCombinerConfig(ic_lookback=20)
    )
    
    # Mock metadata: strategy A has higher expected_ic
    metadata_dict = {
        'A': SignalMetadata(
            quality_metrics=SignalQualityMetrics(expected_ic=0.05)
        ),
        'B': SignalMetadata(
            quality_metrics=SignalQualityMetrics(expected_ic=0.03)
        )
    }
    
    # Mock performance: strategy Bå®é™…è¡¨ç°æ›´å¥½
    performance_history = pd.DataFrame({
        'date': pd.date_range('2024-01-01', periods=30),
        'strategy': ['A']*30 + ['B']*30,
        'realized_ic': [0.02]*30 + [0.06]*30  # Bçš„realized ICæ›´é«˜
    })
    
    # Act
    weights = combiner._compute_weights(metadata_dict, performance_history)
    
    # Assert: Båº”è¯¥å¾—åˆ°æ›´é«˜æƒé‡ï¼ˆå› ä¸ºrealized ICæ›´é«˜ï¼‰
    assert weights['B'] > weights['A']
```

#### **åœºæ™¯3: Signal Metadata Propagation**
```python
def test_metadata_propagates_through_meta_strategy():
    """æµ‹è¯•metadataæ­£ç¡®ä¼ é€’é€šè¿‡MetaStrategy"""
    # Setup
    base_strategies = [
        MockStrategy(name='A', expected_ic=0.04),
        MockStrategy(name='B', expected_ic=0.03)
    ]
    meta_strategy = MetaStrategy(
        config=MetaStrategyConfig(...),
        base_strategies=base_strategies
    )
    
    # Act
    signals, metadata = meta_strategy.generate_signals(pipeline_data)
    
    # Assert
    assert isinstance(metadata, SignalMetadata)
    assert metadata.strategy_name == meta_strategy.name
    # Combined metadataåº”è¯¥æ˜¯weighted average
    expected_combined_ic = 0.6 * 0.04 + 0.4 * 0.03  # å‡è®¾weightsæ˜¯[0.6, 0.4]
    assert abs(metadata.quality_metrics.expected_ic - expected_combined_ic) < 0.001
```

#### **åœºæ™¯4: Experiment Runner**
```python
def test_experiment_runner_generates_correct_combinations():
    """æµ‹è¯•experiment runnerç”Ÿæˆæ­£ç¡®çš„é…ç½®ç»„åˆ"""
    experiment = ExperimentConfig(
        name='test',
        base_config=base_config,
        variations=[
            ConfigVariation(
                name='freq',
                config_path='competition.rebalance_frequency',
                values=['daily', 'weekly']
            ),
            ConfigVariation(
                name='lookback',
                config_path='strategies.ml.lookback_window',
                values=[60, 120]
            )
        ]
    )
    
    runner = ExperimentRunner(experiment)
    configs = runner._generate_config_combinations()
    
    # Assert
    assert len(configs) == 2 * 2  # 4ä¸ªç»„åˆ
    
    # æ£€æŸ¥æ¯ä¸ªç»„åˆç¡®å®ä¸åŒ
    freqs = [cfg.competition.rebalance_frequency for cfg in configs]
    lookbacks = [cfg.strategies['ml'].lookback_window for cfg in configs]
    
    assert set(freqs) == {'daily', 'weekly'}
    assert set(lookbacks) == {60, 120}
```

---

## ğŸ”„ æŒç»­æ”¹è¿›å»ºè®®

é‡æ„å®Œæˆåï¼Œè¿˜å¯ä»¥è€ƒè™‘çš„å¢å¼ºåŠŸèƒ½:

### **Phase 2åŠŸèƒ½ï¼ˆå¯é€‰ï¼ŒæŒ‰éœ€å®ç°ï¼‰**

#### **1. Signal Quality Monitoring**
```
åŠŸèƒ½:
- å®æ—¶ç›‘æ§å„strategyçš„IC decay
- å½“ICæ˜¾è‘—ä¸‹é™æ—¶å‘å‡ºè­¦å‘Š
- è‡ªåŠ¨disableè¡¨ç°å·®çš„strategies

ä»·å€¼:
- é¿å…ä½¿ç”¨å·²å¤±æ•ˆçš„signals
- æé«˜overall portfolio quality

å®ç°éš¾åº¦: ä¸­
ä¼˜å…ˆçº§: ä¸­
```

#### **2. Adaptive Rebalance Frequency**
```
åŠŸèƒ½:
- æ ¹æ®signal decayè‡ªåŠ¨è°ƒæ•´rebalanceé¢‘ç‡
- Decayå¿«çš„signalsæ›´é¢‘ç¹rebalance
- Decayæ…¢çš„signalsé™ä½rebalanceé¢‘ç‡

ä»·å€¼:
- ä¼˜åŒ–turnover vs performance trade-off
- æ¯ä¸ªsignalç”¨æœ€é€‚åˆçš„é¢‘ç‡

å®ç°éš¾åº¦: é«˜
ä¼˜å…ˆçº§: ä½ï¼ˆå…ˆå›ºå®šé¢‘ç‡ï¼ŒéªŒè¯æ•ˆæœåå†è€ƒè™‘ï¼‰
```

#### **3. Multi-Period Optimization**
```
åŠŸèƒ½:
- Portfolio optimizationè€ƒè™‘å¤šæœŸç›®æ ‡
- ä¸åªä¼˜åŒ–ä¸‹ä¸€æœŸï¼Œè€Œæ˜¯ä¼˜åŒ–æœªæ¥NæœŸçš„expected return
- è€ƒè™‘signalçš„decay profile

ä»·å€¼:
- æ›´sophisticatedçš„optimization
- ç†è®ºä¸Šèƒ½æé«˜long-term performance

å®ç°éš¾åº¦: é«˜
ä¼˜å…ˆçº§: ä½ï¼ˆå±äºç ”ç©¶çº§åŠŸèƒ½ï¼‰
```

#### **4. Risk Model Integration**
```
åŠŸèƒ½:
- é›†æˆå®Œæ•´çš„risk modelï¼ˆä¸åªæ˜¯ç®€å•çš„volatilityï¼‰
- Factor-based covariance estimation
- Stress testing

ä»·å€¼:
- æ›´robustçš„portfolio construction
- æ›´å¥½çš„é£é™©ç®¡ç†

å®ç°éš¾åº¦: é«˜
ä¼˜å…ˆçº§: ä¸­ï¼ˆå¦‚æœcompetitionçœ‹é‡risk-adjusted returnï¼‰
```

#### **5. Web UI for Experiment Management**
```
åŠŸèƒ½:
- Webç•Œé¢é…ç½®å’Œè¿è¡Œå®éªŒ
- å®æ—¶æŸ¥çœ‹å®éªŒè¿›åº¦
- äº¤äº’å¼ç»“æœåˆ†æ

ä»·å€¼:
- é™ä½ä½¿ç”¨é—¨æ§›
- æ›´å¥½çš„å¯è§†åŒ–

å®ç°éš¾åº¦: é«˜
ä¼˜å…ˆçº§: ä½ï¼ˆCLIå¤Ÿç”¨çš„æƒ…å†µä¸‹ï¼‰
```

---

## ğŸ’¡ ç»™ä½ çš„æœ€åå»ºè®®

### **å®æ–½å»ºè®®**

**1. ä¸¥æ ¼æŒ‰é˜¶æ®µè¿›è¡Œ**
```
ä¸è¦è¯•å›¾ä¸€æ¬¡æ€§é‡æ„æ‰€æœ‰ä¸œè¥¿
æ¯å®Œæˆä¸€ä¸ªé˜¶æ®µå°±æµ‹è¯•å’ŒéªŒè¯
ç¡®ä¿æ¯ä¸ªé˜¶æ®µéƒ½æ˜¯ç¨³å®šçš„beforeè¿›å…¥ä¸‹ä¸€é˜¶æ®µ
```

**2. å……åˆ†åˆ©ç”¨ç±»å‹ç³»ç»Ÿ**
```
é…ç½®mypyå’Œpylint
åœ¨CIä¸­è¿è¡Œç±»å‹æ£€æŸ¥
IDEé…ç½®å¥½ç±»å‹æç¤º
```

**3. å†™æµ‹è¯•ä¼˜å…ˆäºå†™å®ç°**
```
å¯¹äºå…³é”®ç»„ä»¶ï¼ˆå¦‚ICWeightedCombinerï¼‰ï¼Œå…ˆå†™æµ‹è¯•
TDDèƒ½å¸®ä½ è®¾è®¡æ›´å¥½çš„æ¥å£
æµ‹è¯•ä¹Ÿæ˜¯æ´»æ–‡æ¡£
```

**4. ä¿æŒå‘åå…¼å®¹æ€§ç›´åˆ°ç¡®è®¤æ–°ç³»ç»Ÿå·¥ä½œ**
```
Week 1-3ä¿æŒæ–°æ—§æ¥å£å…±å­˜
åªæœ‰åœ¨Week 4å…¨é¢æµ‹è¯•é€šè¿‡åæ‰åˆ é™¤æ—§ä»£ç 
è¿™ç»™ä½ ä¸€ä¸ªsafety net
```

**5. è®°å½•æ‰€æœ‰å†³ç­–**
```
ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ
è€ƒè™‘äº†å“ªäº›alternativesï¼Ÿ
æœ‰ä»€ä¹ˆtrade-offsï¼Ÿ

è¿™äº›è®°å½•åœ¨æœªæ¥é‡æ„æ—¶éå¸¸æœ‰ä»·å€¼
```

---

### **é£é™©ç®¡ç†**

**é«˜é£é™©ç‚¹**:
1. **Week 1 Day 5**: è¿ç§»æ‰€æœ‰strategiesï¼Œå¦‚æœæœ‰é—®é¢˜ä¼šé˜»å¡åç»­
2. **Week 2 Day 4**: MetaStrategyé‡æ„ï¼Œå¦‚æœIC trackingæœ‰bugä¼šå½±å“ç»“æœ
3. **Week 4 Day 2**: Backtest Engineæ”¹é€ ï¼Œå¦‚æœæœ‰regressionä¼šå½±å“æ‰€æœ‰å®éªŒ

**ç¼“è§£ç­–ç•¥**:
- æ¯ä¸ªé«˜é£é™©ç‚¹å¢åŠ æµ‹è¯•æ—¶é—´
- å‡†å¤‡rollback plan
- å…³é”®èŠ‚ç‚¹åšcheckpoint

---

### **æˆåŠŸæ ‡å¿—**

**æŠ€æœ¯å±‚é¢**:
- âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼ˆè¦†ç›–ç‡>85%ï¼‰
- âœ… Mypyæ£€æŸ¥æ— é”™è¯¯
- âœ… èƒ½å¤ŸæˆåŠŸè¿è¡Œå®Œæ•´çš„experiment matrix
- âœ… æ–°æ—§ç³»ç»Ÿçš„backtestç»“æœä¸€è‡´ï¼ˆnumeric toleranceå†…ï¼‰

**ä½“éªŒå±‚é¢**:
- âœ… æ·»åŠ æ–°strategyç¡®å®åªéœ€æ”¹é…ç½®
- âœ… é˜Ÿå‹èƒ½å¤Ÿç‹¬ç«‹ä½¿ç”¨æ–°ç³»ç»Ÿåšå®éªŒ
- âœ… Debugæ—¶é—´æ˜¾è‘—å‡å°‘
- âœ… é…ç½®é”™è¯¯åœ¨åŠ è½½æ—¶å°±è¢«å‘ç°

**ä¸šåŠ¡å±‚é¢**:
- âœ… èƒ½å¤Ÿå¿«é€Ÿæµ‹è¯•ä¸åŒsignalç»„åˆ
- âœ… MetaStrategyçš„IC-weightedç¡®å®æ¯”fixed weightså¥½
- âœ… å®éªŒç»“æœå¯è¿½æº¯ä¸”å¯å¤ç°
- âœ… ä¸ºç«èµ›æä¾›äº†æ˜¾è‘—ä¼˜åŠ¿

---

## ğŸ¯ æ ¸å¿ƒä»·å€¼ä¸»å¼ 

è¿™æ¬¡é‡æ„æœ€ç»ˆå¸¦æ¥çš„ä»·å€¼:

**1. ç ”ç©¶æ•ˆç‡æå‡**
```
ä»æƒ³æ³•åˆ°éªŒè¯çš„æ—¶é—´:
æ”¹é€ å‰: æ”¹ä»£ç  â†’ æµ‹è¯• â†’ debug â†’ é‡è·‘ = 2-3å°æ—¶
æ”¹é€ å: æ”¹é…ç½® â†’ è¿è¡Œ = 5åˆ†é’Ÿ

å®éªŒthroughputæå‡: ~20-30x
```

**2. ä»£ç è´¨é‡æå‡**
```
Bugå‘ç°æ—¶æœº:
æ”¹é€ å‰: Runtime (backtestè·‘äº†1å°æ—¶æ‰crash)
æ”¹é€ å: Config load time (1ç§’å†…å‘ç°)

Debugæ—¶é—´å‡å°‘: ~10x
```

**3. ç³»ç»Ÿå¯æ‰©å±•æ€§æå‡**
```
æ·»åŠ æ–°åŠŸèƒ½çš„æˆæœ¬:
æ”¹é€ å‰: ä¿®æ”¹å¤šå¤„ä»£ç ï¼Œå®¹æ˜“å¼•å…¥bug
æ”¹é€ å: å®ç°æ–°ç»„ä»¶ï¼Œæ³¨å†Œåˆ°factory

å¼€å‘é€Ÿåº¦æå‡: ~3-5x
```

**4. å›¢é˜Ÿåä½œæ•ˆç‡æå‡**
```
çŸ¥è¯†ä¼ é€’æˆæœ¬:
æ”¹é€ å‰: éœ€è¦ç†è§£æ•´ä¸ªcodebaseæ‰èƒ½æ”¹ä¸œè¥¿
æ”¹é€ å: åªéœ€ç†è§£æ¥å£å’Œé…ç½®schema

æ–°äººä¸Šæ‰‹æ—¶é—´: ä»æ•°å¤© â†’ æ•°å°æ—¶
```

**5. ç«èµ›è¡¨ç°æå‡**
```
é€šè¿‡å¿«é€Ÿå®éªŒæ‰¾åˆ°æœ€ä¼˜é…ç½®:
æ”¹é€ å‰: æ—¶é—´é™åˆ¶ä¸‹åªèƒ½æµ‹è¯•å°‘æ•°é…ç½®
æ”¹é€ å: èƒ½å¤Ÿç³»ç»ŸåŒ–åœ°æµ‹è¯•å¤§é‡é…ç½®

æ‰¾åˆ°æœ€ä¼˜è§£çš„æ¦‚ç‡: æ˜¾è‘—æå‡
```

---

## ğŸ æ€»ç»“

è¿™ä¸ªè·¯å¾„Cçš„æ–¹æ¡ˆæ˜¯ä¸€ä¸ª**å®Œæ•´çš„ã€ç”Ÿäº§çº§çš„æ¶æ„é‡æ„**ï¼Œå®ƒä¸æ˜¯ç®€å•çš„bugä¿®å¤ï¼Œè€Œæ˜¯å»ºç«‹äº†ä¸€ä¸ªsolidçš„foundationï¼Œèƒ½å¤Ÿæ”¯æ’‘ä½ çš„é•¿æœŸç ”ç©¶éœ€æ±‚ã€‚

**æ ¸å¿ƒæ€æƒ³**:
- **æ˜¾å¼ä¼˜äºéšå¼**: æ‰€æœ‰ä¾èµ–å’Œçº¦æŸéƒ½æ˜¾å¼å£°æ˜
- **é…ç½®é©±åŠ¨**: ç ”ç©¶é€»è¾‘åœ¨é…ç½®ä¸­ï¼Œä¸åœ¨ä»£ç ä¸­
- **ç±»å‹å®‰å…¨**: è®©ç±»å‹ç³»ç»Ÿå¸®ä½ catché”™è¯¯
- **Metadata-aware**: Signal qualityæ˜¯first-class citizen
- **Fail-fast**: é—®é¢˜åœ¨æœ€æ—©çš„æ—¶æœºè¢«å‘ç°

**å…³é”®æˆæœ**:
- ä½ ä¼šæœ‰ä¸€ä¸ªå¯ä»¥é•¿æœŸä½¿ç”¨ã€ä¸æ–­æ‰©å±•çš„ç³»ç»Ÿ
- ä½ çš„ç ”ç©¶æ•ˆç‡ä¼šæ˜¾è‘—æå‡
- ä½ çš„ä»£ç è´¨é‡ä¼šè¾¾åˆ°ç”Ÿäº§çº§æ°´å¹³
- ä½ ä¸ºæœªæ¥çš„é¡¹ç›®å»ºç«‹äº†å¯å¤ç”¨çš„æ¨¡å¼

**æœ€é‡è¦çš„æ˜¯**: è¿™ä¸ªæ¶æ„**å®ç°äº†ä½ åŸå§‹æ–¹æ¡ˆçš„æ ¸å¿ƒç›®æ ‡** â€”â€” é…ç½®é©±åŠ¨çš„alphaä¿¡å·ç”Ÿæˆä¸ç»„åˆã€‚å®ƒä¸æ˜¯ä¸ºäº†é‡æ„è€Œé‡æ„ï¼Œè€Œæ˜¯ä¸ºäº†è®©ä½ èƒ½å¤Ÿ**çœŸæ­£åœ°ã€ç³»ç»ŸåŒ–åœ°ã€é«˜æ•ˆåœ°**åšquantitative researchã€‚